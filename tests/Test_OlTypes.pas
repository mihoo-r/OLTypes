unit Test_OlTypes;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, Windows, Forms, Dialogs, Controls, Classes, SysUtils, Variants, Graphics,
        Messages, OLTypes;

type
        // Test methods for class TMock

  OLBooleanTest = class(TTestCase)
  published
    procedure SetBoolean;

    procedure EqualsBoolean;
    procedure NotEqualBoolean;
    procedure GreaterBoolean;
    procedure GreaterEqualBoolean;
    procedure LessBoolean;
    procedure LessEqualBoolean;

    procedure IsNullBoolean;
    procedure ToStringBoolean;

    procedure AndBoolean;
    procedure OrBolean;
    procedure NotBoolean;
    procedure XorBoolean;

    procedure IfThenBoolean;
  end;

  OLIntegerTest = class(TTestCase)
  published
    procedure EqualsInteger;
    procedure GreaterEqualInteger;
    procedure GreaterInteger;
    procedure IsNullInteger;
    procedure LessEqualInteger;
    procedure LessInteger;
    procedure NotEqualInteger;
    procedure SetInteger;
    procedure ToStringInteger;

    procedure IsDividableInteger;
    procedure OddEvenInteger;
    procedure PowerInteger;
    procedure PositiveNegativeInteger;
    procedure MaxInteger;
    procedure MinInteger;
    procedure AbsInteger;
    procedure IfNullInteger;
    procedure RoundInteger;
    procedure ForLoopInteger;
    procedure IdPrimeInteger;
    procedure SetRandomPrimeInteger;
    procedure MathOperatorsInteger;
  end;

  OLCurrencyTest = class(TTestCase)
  published
    procedure EqualsCurrency;
    procedure GreaterCurrency;
    procedure GreaterEqualCurrency;
    procedure IfNullCurrency;
    procedure IsNullCurrency;
    procedure LessCurrency;
    procedure LessEqualCurrency;
    procedure NotEqualCurrency;
    procedure SetCurrency;
    procedure ToStringCurrency;

    procedure PowerCurrency;
    procedure PositiveNegativeCurrency;
    procedure MaxCurrency;
    procedure MinCurrency;
    procedure AbsCurrency;
    procedure RoundCurrency;
    procedure MathOperatorsCurrency;
  end;

  OLDoubleTest = class(TTestCase)
  published
    procedure EqualsDouble;
    procedure GreaterDouble;
    procedure GreaterEqualDouble;
    procedure IfNullDouble;
    procedure IsNullDouble;
    procedure LessDouble;
    procedure LessEqualDouble;
    procedure NotEqualDouble;
    procedure SetDouble;
    procedure ToStringDouble;
    procedure MathOperatorsDouble;

    procedure PowerDouble;
    procedure PositiveNegativeDouble;
    procedure MaxDouble;
    procedure MinDouble;
    procedure AbsDouble;
    procedure RoundDouble;
    procedure FloorDouble;
    procedure CeilDouble;
    procedure IsNanDouble;
    procedure IsInfiniteDouble;
    procedure IsZeroDouble;
    procedure InRangeDouble;
    procedure EnsureRangeDouble;
    procedure SameValueDouble;
  end;

  OLDateTimeTest = class(TTestCase)
  published
    procedure EqualsDateTime;
    procedure GreaterDateTime;
    procedure GreaterEqualDateTime;
    procedure IsNullDateTime;
    procedure LessDateTime;
    procedure LessEqualDateTime;
    procedure NotEqualDateTime;
    procedure SetDateTime;
    procedure ToStringDateTime;
    procedure MathOperatorsDateTime;

    procedure DateOfDateTime;
    procedure TimeOfDateTime;
    procedure IsInLeapYearDateTime;
    procedure AMPMDateTime;
    procedure WeeksInYearDateTime;
    procedure DaysInYearDateTime;
    procedure DaysInMonthDateTime;
    procedure NowDateTime;
    procedure TodayDateTime;
    procedure TomorrowDateTime;
    procedure YesterdayDateTime;
    procedure IsTodayDateTime;
    procedure SameDayDateTime;
    procedure DateTimePartsOfDateTime;
    procedure StartOfEndOfDateTime;
    procedure CountDateTime;
    procedure SpanDateTime;
    procedure IncDateTime;
    procedure RecodingDateTime;
    procedure SameTimeDateTime;
    procedure DateTimePartsDateTime;
  end;

  OLDateTest = class(TTestCase)
  published
    procedure EqualsDate;
    procedure GreaterDate;
    procedure GreaterEqualDate;
    procedure IsNullDate;
    procedure LessDate;
    procedure LessEqualDate;
    procedure NotEqualDate;
    procedure SetDate;
    procedure ToStringDate;
    procedure MathOperatorsDate;

    procedure IsInLeapYearDate;
    procedure WeeksInYearDate;
    procedure DaysInYearDate;
    procedure DaysInMonthDate;
    procedure TodayDate;
    procedure TomorrowDate;
    procedure YesterdayDate;
    procedure IsTodayDate;
    procedure SameDayDate;
    procedure DatePartsOfDate;
    procedure StartOfEndOfDate;
    procedure CountDate;
    procedure SpanDate;
    procedure IncDate;
    procedure RecodingDate;
    procedure DateTimePartsDate;
  end;

  OLStringTest = class(TTestCase)
  private
    function GetTemp: String;
    function ConnectedToInternet: boolean;
  published
    procedure EqualsString;
    procedure GreaterString;
    procedure GreaterEqualString;
    procedure IsNullString;
    procedure LessString;
    procedure LessEqualString;
    procedure NotEqualString;
    procedure SetString;
    procedure ToStringString;
    procedure MathOperatorsString;

    procedure GetLineStartPositionString;
    procedure CSVFieldValueString;
    procedure LengthString;
    procedure ContainsString;
    procedure DupeString;
    procedure StartsEndsString;
    procedure IndexString;
    procedure MatchString;
    procedure MidStrString;
    procedure FindPatternString;
    procedure PositionString;
    procedure ReplaceString;
    procedure ReverseString;
    procedure LeftRightString;
    procedure SplitString;
    procedure InsertDeleteString;
    procedure FilePathExtract;
    procedure FormatString;
    procedure LastDelimiterString;
    procedure LowerUpperCaseString;
    procedure TrimmedString;
    procedure QuotedString;
    procedure SameString;
    procedure DigitsOnlyNoSpacesString;
    procedure LeadTrailAddString;
    procedure ConvertString;
    procedure SmartToDateString;
    procedure Base64String;
    procedure CompressionString;
    procedure IncludeExcludeFinalCharString;
    procedure OccurrancesString;
    procedure LinesString;
    procedure HashString;
    procedure GetFromURLString;
    procedure IBANString;
  end;

implementation

uses DateUtils, Math, Types, WinInet;

procedure OLCurrencyTest.AbsCurrency;
var
  b: OLCurrency;
begin
  b := -5.1234;
  Check(b.Abs() = 5.1234);
  b := 0;
  Check(b.Abs() = 0);
  b := 1.1234;
  Check(b.Abs() = 1.1234);
end;

procedure OLDoubleTest.AbsDouble;
var
  b: OLDouble;
begin
  b := -5.1234;
  Check(b.Abs() = 5.1234);
  b := 0;
  Check(b.Abs() = 0);
  b := 1.1234;
  Check(b.Abs() = 1.1234);
end;

procedure OLIntegerTest.AbsInteger;
var
  b: OLInteger;
begin
  b := -5;
  Check(b.Abs() = 5);
  b := 0;
  Check(b.Abs() = 0);
  b := 1;
  Check(b.Abs() = 1);
end;

procedure OLDateTimeTest.AMPMDateTime;
var
  b: OLDateTime;
begin
  b := EncodeDateTime(2016,1,10,10,10,10,100);
  Check(b.IsAM());
  CheckFalse(b.IsPM);

  b := EncodeDateTime(2017,1,10,23,10,10,100);
  CheckFalse(b.IsAM());
  Check(b.IsPM);
end;

procedure OLBooleanTest.AndBoolean;
var
  b: OLBoolean;
begin
  b := true;

  CheckTrue(b and true);
end;

procedure OLDoubleTest.CeilDouble;
var
  b: OLDouble;
begin
  b := 123.149;
  Check(b.Ceil() = 124);

  b := -123.149;
  Check(b.Ceil() = -123);
end;


procedure OLDateTest.CountDate;
var
  b, b2: OLDate;
begin
  b.SetToday();

  Check(b.DayOfTheYear() = DayOfTheYear(b));
  Check(b.DayOfTheWeek() = DayOfTheWeek(b));
end;

procedure OLDateTimeTest.CountDateTime;
var
  b, b2: OLDateTime;
  i: OLInteger;
begin
  b.SetNow();

  Check(b.DayOfTheYear() = DayOfTheYear(b));
  Check(b.HourOfTheYear() = HourOfTheYear(b));
  Check(b.MinuteOfTheYear() = MinuteOfTheYear(b));
  Check(b.SecondOfTheYear() = SecondOfTheYear(b));
  Check(b.MilliSecondOfTheYear() = MilliSecondOfTheYear(b));

  Check(b.HourOfTheMonth() = HourOfTheMonth(b));
  Check(b.MinuteOfTheMonth() = MinuteOfTheMonth(b));
  Check(b.SecondOfTheMonth() = SecondOfTheMonth(b));
  Check(b.MilliSecondOfTheMonth() = MilliSecondOfTheMonth(b));

  Check(b.DayOfTheWeek() = DayOfTheWeek(b));
  Check(b.HourOfTheWeek() = HourOfTheWeek(b));
  Check(b.MinuteOfTheWeek() = MinuteOfTheWeek(b));
  Check(b.SecondOfTheWeek() = SecondOfTheWeek(b));
  Check(b.MilliSecondOfTheWeek() = MilliSecondOfTheWeek(b));

  Check(b.MinuteOfTheDay() = MinuteOfTheDay(b));
  Check(b.SecondOfTheDay() = SecondOfTheDay(b));
  Check(b.MilliSecondOfTheDay() = MilliSecondOfTheDay(b));

  Check(b.SecondOfTheHour() = SecondOfTheHour(b));
  Check(b.MilliSecondOfTheHour() = MilliSecondOfTheHour(b));

  Check(b.MilliSecondOfTheMinute() = MilliSecondOfTheMinute(b));

  b.SetNow();
  b := b.RecodedMilliSecond(0);
  i := OLDateTime.SecondCount();
  b2 := OLDateTime.DateTimeFromSecondCount(i);
  Check(b2 = b);
end;

procedure OLDateTimeTest.DateOfDateTime;
var
  b: OLDateTime;
begin
  b := Now();

  Check(b.DateOf() = Date());
end;

procedure OLDateTest.DatePartsOfDate;
var
  b: OLDate;
begin
  b := EncodeDate(2017,1,10);

  Check(b.YearOf() = 2017);
  Check(b.MonthOf() = 1);
  Check(b.DayOf() = 10);
end;

procedure OLDateTest.DateTimePartsDate;
var
  dtp: TDateTimeParts;
  d, d2: OLDate;
begin
  d.SetToday;
  d2.SetToday;

  dtp := d.DateTimeParts;
  dtp.Day := 6 ;
  d2.DateTimeParts := dtp;

  Check(d.RecodedDay(6) = d2);

  dtp.DateTime := Now();
  d.DateTimeParts := dtp;
  Check(d = dtp.DateTime);
end;

procedure OLDateTimeTest.DateTimePartsDateTime;
var
  dtp: TDateTimeParts;
  d, d2: OLDateTime;
begin
  d.SetNow;
  d2.SetNow;

  dtp := d.DateTimeParts;
  dtp.Hour := 4;
  d2.DateTimeParts := dtp;

  Check(d.RecodedHour(4) = d2);

  dtp.DateTime := Now();
  d.DateTimeParts := dtp;
  Check(d = dtp.DateTime);
end;

procedure OLDateTimeTest.DateTimePartsOfDateTime;
var
  b: OLDateTime;
begin
  b := EncodeDateTime(2017,1,10,9,38,15,100);

  Check(b.YearOf() = 2017);
  Check(b.MonthOf() = 1);
  Check(b.DayOf() = 10);
  Check(b.HourOf() = 9);
  Check(b.MinuteOf() = 38);
  Check(b.SecondOf() = 15);
  Check(b.MilliSecondOf() = 100);
end;

procedure OLDateTest.DaysInMonthDate;
var
  b: OLDate;
  d: TDate;
  i: integer;
begin
  d := EncodeDate(2017,1,10);

  for i := 1 to 20 do
  begin
    d := IncMonth(d);
    b := d;
    Check(b.DaysInMonth = DaysInMonth(d));
  end;
end;

procedure OLDateTimeTest.DaysInMonthDateTime;
var
  b: OLDateTime;
  dt: TDateTime;
  i: integer;
begin
  dt := EncodeDateTime(2017,1,10,10,10,10,100);

  for i := 1 to 20 do
  begin
    dt := IncMonth(dt);
    b := dt;
    Check(b.DaysInMonth = DaysInMonth(dt));
  end;
end;

procedure OLDateTest.DaysInYearDate;
var
  b: OLDate;
  d: TDate;
  i: integer;
begin
  for i := 2000 to 2020 do
  begin
    d := EncodeDate(i,1,10);
    b := d;
    Check(b.DaysInYear = DaysInYear(d));
  end;
end;

procedure OLDateTimeTest.DaysInYearDateTime;
var
  b: OLDateTime;
  dt: TDateTime;
  i: integer;
begin
  for i := 2000 to 2020 do
  begin
    dt := EncodeDateTime(i,1,10,10,10,10,100);
    b := dt;
    Check(b.DaysInYear = DaysInYear(dt));
  end;
end;

procedure OLDoubleTest.EnsureRangeDouble;
var
  b: OLDouble;
begin
  b := 0;
  b := b.EnsureRange(5.5, 10);
  Check(b = 5.5);

  b := b.EnsureRange(-100, -1.0001);
  Check(b = -1.0001);
end;

procedure OLBooleanTest.EqualsBoolean;
var
  b: OLBoolean;
begin
  CheckTrue(b = Null);

  b := True;

  CheckFalse(b = Null);

  CheckTrue(b = True);
  CheckFalse(b = False);
end;

procedure OLBooleanTest.GreaterBoolean;
var
  b: OLBoolean;
begin
  CheckFalse(b > Null);

  b := true;

  CheckFalse(b > Null);

  CheckTrue(b > False);
  CheckFalse(b > True);
end;

procedure OLBooleanTest.GreaterEqualBoolean;
var
  b: OLBoolean;
begin
  CheckTrue(b >= Null);

  b := True;

  CheckFalse(b >= Null);

  CheckTrue(b >= False);
  CheckTrue(b >= True);

  b := False;
  CheckFalse(b >= True);
end;

procedure OLIntegerTest.IdPrimeInteger;
var
  b: OLInteger;
begin
  CheckFalse(b.IsPrime());

  b := 1984441079;
  Check(b.IsPrime());

  b := 97496039;
  Check(b.IsPrime());

  b := 97496033;
  CheckFalse(b.IsPrime());
end;

procedure OLIntegerTest.IfNullInteger;
var
  b: OLInteger;
begin
  Check(b.IfNull(1) = 1);

  b := -1;
  Check(b.IfNull(1) = -1);

  b := null;
  Check(b.IfNull(-5) = -5);
end;

procedure OLBooleanTest.IfThenBoolean;
var
  b: OLBoolean;
  c1, c2: Currency;
begin
  b := False;

  Check(b.IfThen(1, 2) = 2);
  Check(b.IfThen(1.1, 2.1) = 2.1);
  Check(b.IfThen(EncodeDate(2000,1,1), EncodeDate(2017, 1, 1)) = EncodeDate(2017, 1, 1));
  Check(b.IfThen(EncodeDateTime(2000,1,1, 12, 0,0,0), EncodeDateTime(2017, 1, 1, 11, 0,0,0)) = EncodeDateTime(2017, 1, 1, 11, 0,0,0));

  c1 := 1.10;
  c2 := 1.20;

  Check(b.IfThen(c1, c2) = c2);

  b := true;

  Check(b.IfThen(1, 2) = 1);
  Check(b.IfThen(1.1, 2.1) = 1.1);
  Check(b.IfThen(EncodeDate(2000,1,1), EncodeDate(2017, 1, 1)) = EncodeDate(2000, 1, 1));
  Check(b.IfThen(EncodeDateTime(2000,1,1, 12, 0,0,0), EncodeDateTime(2017, 1, 1, 11, 0,0,0)) = EncodeDateTime(2000, 1, 1, 12, 0,0,0));

  c1 := 1.10;
  c2 := 1.20;

  Check(b.IfThen(c1, c2) = c1);
end;

procedure OLDateTest.IncDate;
var
  d, d2: OLDate;
begin
  d.EncodeDate(2000, 1,2);

  d2.EncodeDate(2000, 1,8);
  Check(d.IncDay(6) = d2);

  d2.EncodeDate(2000, 1,16);
  Check(d.IncWeek(2) = d2);

  d2.EncodeDate(2000, 3,2);
  Check(d.IncMonth(2) = d2);

  d2.EncodeDate(2004, 1,2);
  Check(d.IncYear(4) = d2);
end;

procedure OLDateTimeTest.IncDateTime;
var
  d, d2: OLDateTime;
begin
  d.EncodeDateTime(2000, 1,2,3,45,25,400);

  d2.EncodeDateTime(2000, 1,2,3,45,25,500);
  Check(d.IncMilliSecond(100) = d2);

  d2.EncodeDateTime(2000, 1,2,3,45,55,400);
  Check(d.IncSecond(30) = d2);

  d2.EncodeDateTime(2000, 1,2,3,40,25,400);
  Check(d.IncMinute(-5) = d2);

  d2.EncodeDateTime(2000, 1,2,16,45,25,400);
  Check(d.IncHour(13) = d2);

  d2.EncodeDateTime(2000, 1,8,3,45,25,400);
  Check(d.IncDay(6) = d2);

  d2.EncodeDateTime(2000, 1,16,3,45,25,400);
  Check(d.IncWeek(2) = d2);

  d2.EncodeDateTime(2000, 3,2,3,45,25,400);
  Check(d.IncMonth(2) = d2);

  d2.EncodeDateTime(2004, 1,2,3,45,25,400);
  Check(d.IncYear(4) = d2);
end;

procedure OLDoubleTest.InRangeDouble;
var
  b: OLDouble;
begin
  b := 0;
  Check(b.InRange(0,100));
  Check(b.InRange(-1,100));
  CheckFalse(b.InRange(1,100));

  b := -0.9999;
  Check(b.InRange(-1,100));
end;

procedure OLIntegerTest.IsDividableInteger;
var
  b: OLInteger;
begin
  b := 5;
  Check(b.IsDividableBy(5));
  CheckFalse(b.IsDividableBy(3));

  b := 6;
  Check(b.IsDividableBy(2));
  Check(b.IsDividableBy(3));
end;

procedure OLDoubleTest.IsInfiniteDouble;
var
  b: OLDouble;
begin
  b := Infinity;
  Check(b.IsInfinite());
end;

procedure OLDateTest.IsInLeapYearDate;
var
  b: OLDate;
begin
  b := EncodeDate(2016,1,10);
  Check(b.IsInLeapYear());

  b := EncodeDate(2017,1,10);
  CheckFalse(b.IsInLeapYear());

  b := EncodeDate(2020,1,10);
  Check(b.IsInLeapYear());
end;

procedure OLDateTimeTest.IsInLeapYearDateTime;
var
  b: OLDateTime;
begin
  b := EncodeDateTime(2016,1,10,10,10,10,100);
  Check(b.IsInLeapYear());

  b := EncodeDateTime(2017,1,10,10,10,10,100);
  CheckFalse(b.IsInLeapYear());

  b := EncodeDateTime(2020,1,10,10,10,10,100);
  Check(b.IsInLeapYear());
end;

procedure OLDoubleTest.IsNanDouble;
var
  b: OLDouble;
begin
  b := NaN;
  Check(b.IsNan());
end;

procedure OLBooleanTest.IsNullBoolean;
var
  b: OLBoolean;
begin
  Check(b.IsNull());

  b := False;
  Check(b.IsNull() = False);

  b := Null;
  Check(b.IsNull());
end;

procedure OLBooleanTest.LessBoolean;
var
  b: OLBoolean;
begin
  b := False;

  CheckFalse(b < False);
  CheckTrue(b < True);
end;

procedure OLBooleanTest.LessEqualBoolean;
var
  b: OLBoolean;
begin
  b := True;

  CheckFalse(b <= False);
  CheckTrue(b <= True);

  b := False;
  CheckTrue(b <= True);
end;

procedure OLBooleanTest.NotBoolean;
var
  b: OLBoolean;
begin
  b := true;

  CheckFalse(not b);

  b := false;

  CheckTrue(not b);
end;

procedure OLBooleanTest.NotEqualBoolean;
var
  b: OLBoolean;
begin
  CheckFalse(b <> Null);

  b := True;

  CheckTrue(b <> Null);

  CheckTrue(b <> False);
  CheckFalse(b <> True);
end;

procedure OLIntegerTest.OddEvenInteger;
var
  b: OLInteger;
begin
  b := 5;
  Check(b.IsOdd());
  CheckFalse(b.IsEven());

  b := 50000000;
  Check(b.IsEven());
  CheckFalse(b.IsOdd());
end;

procedure OLBooleanTest.OrBolean;
var
  b: OLBoolean;
begin
  b := true;

  CheckTrue(b or False);

  b := False;

  CheckTrue(b or True);
  CheckFalse(b or False);
end;

procedure OLCurrencyTest.PositiveNegativeCurrency;
var
  b: OLCurrency;
begin
  b := 5.0001;
  Check(b.IsPositive());
  CheckFalse(b.IsNegative());
  Check(b.IsNonNegative());

  b := 0;
  CheckFalse(b.IsPositive());
  CheckFalse(b.IsNegative());
  Check(b.IsNonNegative());

  b := -5.0001;
  CheckFalse(b.IsPositive());
  Check(b.IsNegative());
  CheckFalse(b.IsNonNegative());
end;

procedure OLDoubleTest.PositiveNegativeDouble;
var
  b: OLDouble;
begin
  b := 5.0001;
  Check(b.IsPositive());
  CheckFalse(b.IsNegative());
  Check(b.IsNonNegative());

  b := 0;
  CheckFalse(b.IsPositive());
  CheckFalse(b.IsNegative());
  Check(b.IsNonNegative());

  b := -5.0001;
  CheckFalse(b.IsPositive());
  Check(b.IsNegative());
  CheckFalse(b.IsNonNegative());
end;

procedure OLIntegerTest.PositiveNegativeInteger;
var
  b: OLInteger;
begin
  b := 5;
  Check(b.IsPositive());
  CheckFalse(b.IsNegative());
  Check(b.IsNonNegative());

  b := 0;
  CheckFalse(b.IsPositive());
  CheckFalse(b.IsNegative());
  Check(b.IsNonNegative());

  b := -5;
  CheckFalse(b.IsPositive());
  Check(b.IsNegative());
  CheckFalse(b.IsNonNegative());
end;

procedure OLCurrencyTest.MathOperatorsCurrency;
var
  b: OLCurrency;
begin
  b := 1.10;

  b := b + 1.25;
  Check(b = 2.35);

  b := b - 4.20;
  Check(b = -1.85);

  b := b * -3;

  Check(b = 5.55);
  Check(b / 2 = 2.775);
  Check(b / 4 = 1.3875);
  Check(b / 1.11 = 5);

  b := -b;
  Check(b = -5.55);
end;

procedure OLDateTest.MathOperatorsDate;
var
  dt, dt2: OLDate;
begin
  dt.SetToday();
  dt2 := dt;

  dt := dt + 1;
  dt2 := dt2.IncDay(1);
  Check(dt = dt2);

  dt := dt - 2;
  dt2 := dt2.IncDay(-2);
  Check(dt = dt2);
end;

procedure OLDateTimeTest.MathOperatorsDateTime;
var
  dt, dt2: OLDateTime;
begin
  dt.SetNow;
  dt2 := dt;

  dt := dt + 1;
  dt2 := dt2.IncDay(1);
  Check(dt = dt2);

  dt := dt - 2.5;
  dt2 := dt2.IncDay(-2).IncHour(-12);
  Check(dt = dt2);
end;

procedure OLDoubleTest.MathOperatorsDouble;
var
  b: OLDouble;
begin
  b := 1.10;

  b := b + 1.25;
  Check(b = 2.35);

  b := b - 4.20;
  Check(b = -1.85);

  b := b * -3;

  Check(b = 5.55);
  Check(b / 2 = 2.775);
  Check(b / 4 = 1.3875);
  Check(b / 1.11 = 5);

  b := -b;
  Check(b = -5.55);
end;

procedure OLIntegerTest.MathOperatorsInteger;
var
  b: OLInteger;
begin
  b := 1;

  b := b + 1;
  Check(b = 2);

  b := b - 4;
  Check(b = -2);

  b := b * -3;

  Check(b = 6);
  Check(b div 4 = 1);
  Check(b / 2 = 3);
  Check(b / 4 = 1.5);
  Check(b / 1.5 = 4);
  Check(b mod 4 = 2);

  Inc(b, 3);
  Check(b = 9);

  Inc(b);
  Check(b = 10);

  Dec(b);
  Check(b = 9);

  Dec(b, 2);
  Check(b = 7);

  b := -b;
  Check(b = -7);
end;

procedure OLStringTest.MatchString;
var
  b: OLString;
begin
  b := 'Three';

  Check(b.MatchStr(['One', 'Two', 'Three']));
  CheckFalse(b.MatchStr(['one', 'two', 'three']));

  Check(b.MatchText(['one', 'two', 'three']));
end;

procedure OLStringTest.MathOperatorsString;
var
  d: OLString;
begin
  d := null;

  //When OLString is NULL, adding a string to it results NULL
  d := d + 'asd';
  Check(d.IsNull());

  d := 'asd';
  d := d + ' zxc';

  Check(d = 'asd zxc');
end;

procedure OLStringTest.MidStrString;
var
  b: OLString;
begin
  b := 'Three little mice.';
  Check(b.MidStr(2,3) = 'hre');
  Check(b.MidStr(7,6) = 'little');
end;

procedure OLCurrencyTest.MaxCurrency;
var
  b: OLCurrency;
begin
  b := 1.1234;
  Check(b.Max(0) = 1.1234);
  Check(b.Max(5.4321) = 5.4321);

  b := -5.4321;
  Check(b.Max(0) = 0);
  Check(b.Max(-6.1) = -5.4321);
  Check(b.Max(-4.201) = -4.201);
end;

procedure OLDoubleTest.MaxDouble;
var
  b: OLDouble;
begin
  b := 1.1234;
  Check(b.Max(0) = 1.1234);
  Check(b.Max(5.4321) = 5.4321);

  b := -5.4321;
  Check(b.Max(0) = 0);
  Check(b.Max(-6.1) = -5.4321);
  Check(b.Max(-4.201) = -4.201);
end;

procedure OLIntegerTest.MaxInteger;
var
  b: OLInteger;
begin
  b := 1;
  Check(b.Max(0) = 1);
  Check(b.Max(5) = 5);

  b := -5;
  Check(b.Max(0) = 0);
  Check(b.Max(-6) = -5);
  Check(b.Max(-4) = -4);
end;

procedure OLCurrencyTest.MinCurrency;
var
  b: OLCurrency;
begin
  b := 1.1234;
  Check(b.Min(0) = 0);
  Check(b.Min(5.4321) = 1.1234);

  b := -5.4321;
  Check(b.Min(0) = -5.4321);
  Check(b.Min(-6.1) = -6.1);
  Check(b.Min(-4.201) = -5.4321);
end;

procedure OLDoubleTest.MinDouble;
var
  b: OLDouble;
begin
  b := 1.1234;
  Check(b.Min(0) = 0);
  Check(b.Min(5.4321) = 1.1234);

  b := -5.4321;
  Check(b.Min(0) = -5.4321);
  Check(b.Min(-6.1) = -6.1);
  Check(b.Min(-4.201) = -5.4321);
end;

procedure OLIntegerTest.MinInteger;
var
  b: OLInteger;
begin
  b := 1;
  Check(b.Min(0) = 0);
  Check(b.Min(5) = 1);

  b := -5;
  Check(b.Min(0) = -5);
  Check(b.Min(-6) = -6);
  Check(b.Min(-4) = -5);
end;

procedure OLCurrencyTest.PowerCurrency;
var
  b: OLCurrency;
begin
  b := 5.1;
  Check(b.Sqr = 26.01);
  Check(b.Power(3) = 132.651);

  b := 0.5;
  Check(b.Power(0) = 1);
  Check(b.Power(-1) = 2);
end;

procedure OLDoubleTest.PowerDouble;
var
  b: OLDouble;
begin
  b := 5.1;
  Check(b.Sqr = 26.01);
  Check(b.Power(3) = 132.651);

  b := 0.5;
  Check(b.Power(0) = 1);
  Check(b.Power(-1) = 2);

  b := 0.81;
  Check(b.Sqrt() = 0.9);
end;

procedure OLIntegerTest.PowerInteger;
var
  b: OLInteger;
begin
  b := 5;
  Check(b.Sqr = 25);
  Check(b.Power(3) = 125);

  b := 2;
  Check(b.Power(0) = 1);
  Check(b.Power(-1) = 0.5);
end;

procedure OLDateTest.RecodingDate;
var
  b: OLDate;
  d: OLDate;
begin
  d := EncodeDate(2017,1,10);

  Check(d.RecodedYear(2016) = EncodeDate(2016,1,10));
  Check(d.RecodedMonth(8).RecodedDay(5) = EncodeDate(2017,8,5));
  Check(d.RecodedMonth(8) = EncodeDate(2017,8,10));
  Check(d.RecodedDay(23) = EncodeDate(2017,1,23));
end;

procedure OLDateTimeTest.RecodingDateTime;
var
  b: OLDateTime;
  d: OLDateTime;
begin
  d := EncodeDateTime(2017,1,10,10,10,10,100);

  Check(d.RecodedYear(2016) = EncodeDateTime(2016,1,10,10,10,10,100));
  Check(d.RecodedMonth(8) = EncodeDateTime(2017,8,10,10,10,10,100));
  Check(d.RecodedDay(23) = EncodeDateTime(2017,1,23,10,10,10,100));
  Check(d.RecodedHour(16) = EncodeDateTime(2017,1,10,16,10,10,100));
  Check(d.RecodedMinute(45) = EncodeDateTime(2017,1,10,10,45,10,100));
  Check(d.RecodedSecond(15) = EncodeDateTime(2017,1,10,10,10,15,100));
  Check(d.RecodedMilliSecond(123) = EncodeDateTime(2017,1,10,10,10,10,123));
end;

procedure OLCurrencyTest.RoundCurrency;
var
  b: OLCurrency;
begin
  b := 123.149;
  Check(b.Round(1) = 120);
  Check(b.Round(2) = 100);

  b := 155.155;
  Check(b.Round(1) = 160);
  Check(b.Round(2) = 200);

  b := 123.149;
  Check(b.Round(-1) = 123.1);
  Check(b.Round(-2) = 123.15);

  b := 155.155;
  Check(b.Round(-1) = 155.2);
  Check(b.Round(-2) = 155.16);
end;

procedure OLDoubleTest.RoundDouble;
var
  b: OLDouble;
begin
  b := 123.149;
  Check(b.Round(1) = 120);
  Check(b.Round(2) = 100);

  b := 155.155;
  Check(b.Round(1) = 160);
  Check(b.Round(2) = 200);

  b := 123.149;
  Check(b.Round(-1) = 123.1);
  Check(b.Round(-2) = 123.15);

  b := 155.155;
  Check(b.Round(-1) = 155.2);
  Check(b.Round(-2) = 155.16);

  b := 0.5;
  Check(b.Round() = 0);
  b := 1.5;
  Check(b.Round() = 2);
  b := 2.5;
  Check(b.Round() = 2);
  b := 3.5;
  Check(b.Round() = 4);

  b := -0.5;
  Check(b.Round() = 0);
  b := -1.5;
  Check(b.Round() = -2);
  b := -2.5;
  Check(b.Round() = -2);
end;

procedure OLIntegerTest.RoundInteger;
var
  b: OLInteger;
begin
  b := 123;
  Check(b.Round(1) = 120);
  Check(b.Round(2) = 100);

  b := 155;
  Check(b.Round(1) = 160);
  Check(b.Round(2) = 200);
end;

procedure OLDateTest.SameDayDate;
var
  b: OLDate;
  dt: OLDate;
begin
  dt := EncodeDate(2017,1,10);

  b := EncodeDate(2017,1,10);
  Check(b.SameDay(dt));

  b := EncodeDate(2017,1,11);
  CheckFalse(b.SameDay(dt));
end;

procedure OLDateTimeTest.SameDayDateTime;
var
  b: OLDateTime;
  dt: OLDateTime;
begin
  dt := EncodeDateTime(2017,1,10,10,10,10,100);

  b := EncodeDateTime(2017,1,10,15,10,10,100);
  Check(b.SameDay(dt));

  b := EncodeDateTime(2017,1,11,10,10,10,100);
  CheckFalse(b.SameDay(dt));
end;


procedure OLDateTimeTest.SameTimeDateTime;
var
  b: OLDateTime;
  dt: OLDateTime;
begin
  dt := EncodeDateTime(2017,1,10,10,10,10,100);

  b := EncodeDateTime(2017,1,15,10,10,10,100);
  Check(b.SameTime(dt));

  b := EncodeDateTime(2017,1,10,14,10,10,100);
  CheckFalse(b.SameTime(dt));
end;

procedure OLDoubleTest.SameValueDouble;
var
  b, b2: OLDouble;
begin
  b := 4.01;
  Check(b.SameValue(4.01));
  CheckFalse(b.SameValue(4.011));
  Check(b.SameValue(4.011, 0.01));
end;

procedure OLBooleanTest.SetBoolean;
var
  b: OLBoolean;
begin
  b := False;
  CheckFalse(b);

  b := True;
  CheckTrue(b);

  b := 'true';
  CheckTrue(b);

  b := 'false';
  CheckFalse(b);

  b := 1;
  CheckTrue(b);

  b := 0;
  CheckFalse(b);
end;

procedure OLDateTest.SpanDate;
var
  d, d2: OLDate;
begin
  d.EncodeDate(2000, 1,2);
  d2 := d.RecodedYear(2004).RecodedMonth(7);

  Check(d2.DaysBetween(d) = DateUtils.DaysBetween(d2, d));
  Check(d2.WeeksBetween(d) = DateUtils.WeeksBetween(d2, d));
  Check(d2.MonthsBetween(d) = DateUtils.MonthsBetween(d2, d));
  Check(d2.YearsBetween(d) = DateUtils.YearsBetween(d2, d));


  Check(d2.YearSpan(d) = DateUtils.YearSpan(d2, d));
  Check(d2.MonthSpan(d) = DateUtils.MonthSpan(d2, d));
  Check(d2.WeekSpan(d) = DateUtils.WeekSpan(d2, d));
end;

procedure OLDateTimeTest.SpanDateTime;
var
  d, d2: OLDateTime;
begin
  d.EncodeDateTime(2000, 1,2,3,45,25,400);
  d2 := d.RecodedYear(2004).RecodedMonth(7);

  Check(d2.MilliSecondsBetween(d) = DateUtils.MilliSecondsBetween(d2, d));
  Check(d2.SecondsBetween(d) = DateUtils.SecondsBetween(d2, d));
  Check(d2.MinutesBetween(d) = DateUtils.MinutesBetween(d2, d));
  Check(d2.HoursBetween(d) = DateUtils.HoursBetween(d2, d));
  Check(d2.DaysBetween(d) = DateUtils.DaysBetween(d2, d));
  Check(d2.WeeksBetween(d) = DateUtils.WeeksBetween(d2, d));
  Check(d2.MonthsBetween(d) = DateUtils.MonthsBetween(d2, d));
  Check(d2.YearsBetween(d) = DateUtils.YearsBetween(d2, d));


  Check(d2.YearSpan(d) = DateUtils.YearSpan(d2, d));
  Check(d2.MonthSpan(d) = DateUtils.MonthSpan(d2, d));
  Check(d2.WeekSpan(d) = DateUtils.WeekSpan(d2, d));
  Check(d2.DaySpan(d) = DateUtils.DaySpan(d2, d));
  Check(d2.HourSpan(d) = DateUtils.HourSpan(d2, d));
  Check(d2.MinuteSpan(d) = DateUtils.MinuteSpan(d2, d));
  Check(d2.SecondSpan(d) = DateUtils.SecondSpan(d2, d));
  Check(d2.MilliSecondSpan(d) = DateUtils.MilliSecondSpan(d2, d));
end;

procedure OLDateTest.StartOfEndOfDate;
var
  d: TDate;
  b: OLDate;
begin
  d := EncodeDate(2017,1,10);
  b := d;

  Check(b.StartOfTheYear() = StartOfTheYear(d));
  Check(b.EndOfTheYear() = EndOfTheYear(d));

  Check(b.StartOfTheMonth() = StartOfTheMonth(d));
  Check(b.EndOfTheMonth() = EndOfTheMonth(d));

  Check(b.StartOfTheWeek() = StartOfTheWeek(d));
  Check(b.EndOfTheWeek() = EndOfTheWeek(d));
end;

procedure OLDateTimeTest.StartOfEndOfDateTime;
var
  dt: TDateTime;
  b: OLDateTime;
begin
  dt := EncodeDateTime(2017,1,10,9,38,15,100);
  b := dt;

  Check(b.StartOfTheYear() = StartOfTheYear(dt));
  Check(b.EndOfTheYear() = EndOfTheYear(dt));

  Check(b.StartOfTheMonth() = StartOfTheMonth(dt));
  Check(b.EndOfTheMonth() = EndOfTheMonth(dt));

  Check(b.StartOfTheWeek() = StartOfTheWeek(dt));
  Check(b.EndOfTheWeek() = EndOfTheWeek(dt));

  Check(b.StartOfTheDay() = StartOfTheDay(dt));
  Check(b.EndOfTheDay() = EndOfTheDay(dt));
end;

procedure OLDateTimeTest.TimeOfDateTime;
var
  b: OLDateTime;
begin
  b := EncodeDateTime(2017,1,10,10,10,10,100);

  Check(b.TimeOf() = EncodeTime(10,10,10,100));
end;

procedure OLBooleanTest.ToStringBoolean;
var
  b: OLBoolean;
begin
  b := True;
  CheckEqualsString('True', b.ToString());

  b := False;
  CheckEqualsString('False', b.ToString());
end;

procedure OLBooleanTest.XorBoolean;
var
  b: OLBoolean;
begin
  b := True;
  CheckTrue(b xor False);
  CheckFalse(b xor True);

  b := False;
  CheckTrue(b xor True);
  CheckFalse(b xor False);
end;

procedure OLDateTest.YesterdayDate;
var
  b: OLDate;
begin
  b.SetYesterday();
  Check(b = Yesterday());

  Check(OLDate.Yesterday() = Yesterday());
end;

procedure OLDateTimeTest.YesterdayDateTime;
var
  b: OLDateTime;
begin
  b.SetYesterday();
  Check(b = Yesterday());

  Check(OLDateTime.Yesterday = Yesterday());
end;

procedure OLIntegerTest.EqualsInteger;
var
  b: OLInteger;
begin
  CheckTrue(b = Null);

  b := 3;

  CheckFalse(b = Null);

  CheckTrue(b = 3);
  CheckFalse(b = 1);
  CheckFalse(b = 1);
  CheckFalse(b = 0);
end;

function OLStringTest.GetTemp: String;
var
  PathLocal : array[0..MAX_PATH] of Char;
begin
  Result := '';
  if GetTempPath(Length(PathLocal), PathLocal)>0 then
  begin
    Result := PathLocal;
  end;
end;

procedure OLStringTest.Base64String;
var
  sl, sl2: TStringList;
  TempFileName, TempFileName2: string;

  b: OLString;
begin
  TempFileName := GetTemp() + 'test.txt';
  TempFileName2 := GetTemp() + 'test2.txt';

  sl := TStringList.Create;
  try
    sl.Add('Test1');
    sl.Add('Test2');

    sl.SaveToFile(TempFileName);

    b.EndcodeBase64FromFile(TempFileName);
    Check(b = 'VGVzdDENClRlc3QyDQo=');

    b.DecodeBase64ToFile(TempFileName2);

    sl2 := TStringList.Create;
    try
      sl2.LoadFromFile(TempFileName2);

      Check(sl.Text = sl2.Text);

    finally
      sl2.Free();
    end;
  finally
    sl.Free();
  end;

  DeleteFile(TempFileName);
  DeleteFile(TempFileName2);
end;

procedure OLStringTest.CompressionString;
var
  b, b2: OLString;
const
  BondText = 'My name is Bond. My name is Bond. My name is Bond. My name is Bond.';
begin
  b := BondText;

  b := b.Compressed();

  b2 := b;

  b2 := b2.Decompressed;

  Check(b2 = BondText);
end;

procedure OLStringTest.ContainsString;
var
  b: OLString;
begin
  b := 'My name is Bond. James Bond.';

  //Case sensitive
  Check(b.ContainsStr('Bond'));
  CheckFalse(b.ContainsStr('bond'));

  //Case insensitive
  Check(b.ContainsText('bond'));
end;

procedure OLStringTest.CSVFieldValueString;
var
  b: OLString;
begin
  b :='First Name;Last Name;City';
  Check(b.CSVFieldCount() = 3);
  Check(b.CSVFieldValue(0) = 'First Name');
  Check(b.CSVFieldValue(1) = 'Last Name');
  Check(b.CSVFieldValue(2) = 'City');

  b :='First Name|Last Name|City|Date';
  Check(b.CSVFieldCount('|') = 4);
  Check(b.CSVFieldValue(0, '|') = 'First Name');
  Check(b.CSVFieldValue(1, '|') = 'Last Name');
  Check(b.CSVFieldValue(2, '|') = 'City');
  Check(b.CSVFieldValue(3, '|') = 'Date');
end;

procedure OLStringTest.DigitsOnlyNoSpacesString;
var
  b: OLString;
begin
  b := 'One 23456';

  Check(b.SpacesRemoved() = 'One23456');
  Check(b.DigitsOnly() = '23456');
end;

procedure OLStringTest.DupeString;
var
  b: OLString;
begin
  b := 'One ';

  Check(b.RepeatedString(5) = 'One One One One One ');
end;

procedure OLStringTest.EqualsString;
var
  b, b2: OLString;
  s: string;
begin
  CheckFalse(b = Null);

  Check(b = '');
  Check(b.IsEmptyStr());

  b := Null;

  CheckTrue(b = Null);

  b := '';

  CheckFalse(b = Null);

  b := 'asd';
  s := 'asd';

  CheckTrue(b = s);
  CheckFalse(b = 'zxc');

  b := Null;
  CheckTrue(b = Null);
end;

procedure OLStringTest.FilePathExtract;
var
  b: OLString;
begin
  b := 'c:\temp\test.txt';
  Check(b.ExtractedFileDriveString() = 'c:');
  Check(b.ExtractedFileDir() = 'c:\temp');
  Check(b.ExtractedFilePath() = 'c:\temp\');
  Check(b.ExtractedFileName() = 'test.txt');
  Check(b.ExtractedFileExt() = '.txt');
end;

procedure OLStringTest.FindPatternString;
var
  b: OLString;
  pat: TStringPatternFind;
begin
  b := 'My name is Bond. My name is James Bond.';

  Check(b.FindPatternStr('name is ', '.') = 'Bond');
  Check(b.FindPatternStr('name is ', '.', 15) = 'James Bond');
  Check(b.FindPatternStr('NAME IS ', '.', 15, csCaseInsensitive) = 'James Bond');

  pat := b.FindPattern('NAME IS ', '.', 1, csCaseInsensitive);
  Check(pat.Value = 'Bond');
  Check(pat.Position = 12);

  b := '<head><title>JB Web Page</title></head>';
  Check(b.FindPatternStr('TITLE') = 'JB Web Page'); //ignoring case as default
  Check(b.FindPatternStr('title', 5, csCaseSensitive) = 'JB Web Page');
  CheckFalse(b.FindPatternStr('TITLE', 5, csCaseSensitive) <> '');

  pat := b.FindPattern('TITLE');
  Check(pat.Value = 'JB Web Page');
  Check(pat.Position = 14);
end;

procedure OLStringTest.FormatString;
var
  b: OLString;
begin
  b := 'My name is %s and I am %d years old.';
  b := b.Formated(['Agnieszka', 18]);
  Check(b = 'My name is Agnieszka and I am 18 years old.');
end;

procedure OLDoubleTest.FloorDouble;
var
  b: OLDouble;
begin
  b := 123.149;
  Check(b.Floor() = 123);

  b := -123.149;
  Check(b.Floor() = -124);
end;

procedure OLIntegerTest.ForLoopInteger;
var
  b: OLInteger;
  i: integer;
begin
  i := 0;
  b.ForLoop(1, 10, procedure
  begin
    Inc(i);
  end);

  Check((i = 10) and (b = 10));

  i := 0;
  b.ForLoop(5, -5, procedure
  begin
    i := i + b;
  end);

  Check((i = 0) and (b = -5));
end;

procedure OLIntegerTest.GreaterInteger;
var
  b: OLInteger;
begin
  b := 3;

  CheckFalse(b > Null);

  CheckTrue(b > 2.1);
  CheckFalse(b > 3);
  CheckFalse(b > 4);
end;

procedure OLStringTest.GreaterString;
var
  b: OLString;
  s: string;
begin
  CheckFalse(b > Null);

  s := 'aaa';
  b := 'bbb';

  CheckFalse(b > Null);

  CheckTrue(b > s);
  CheckFalse(b > b);
end;

procedure OLStringTest.HashString;
var
  b: OLString;
begin
  b := 'p@ssword753';

  Check(b.Hash() = 732684085);
  Check(b.HashStr() = '2BABDF35');

  Check(b.Hash('s@It') = 3549827675);
  Check(b.HashStr('s@It') = 'D396125B');
end;

procedure OLIntegerTest.GreaterEqualInteger;
var
  b: OLInteger;
begin
  CheckTrue(b >= Null);

  b := 3;

  CheckFalse(b >= Null);

  CheckTrue(b >= 2.1);
  CheckTrue(b >= 3);

  b := -3;
  CheckFalse(b >= -2);
end;

function OLStringTest.ConnectedToInternet : boolean;
var
  origin : cardinal;
begin
   result := InternetGetConnectedState(@origin, 0);
end;

procedure OLStringTest.GetFromURLString;
var
  b: OLString;
begin
  if ConnectedToInternet() then
  begin
    b.GetFromUrl('https://www.google.com');
    Check(b.FindPatternStr('title').ContainsText('google'));
  end
  else
    Fail('Cannot be testet without Internet connection.');
end;

procedure OLStringTest.GetLineStartPositionString;
var
  b: OLString;
begin
  b :='';
  b.LineAdd('12345');
  b.LineAdd('890123');

  Check(b.GetLineStartPosition(0) = 1);
  Check(b.GetLineStartPosition(1) = 8);
end;

procedure OLStringTest.GreaterEqualString;
var
  b: OLString;
  s, s2: string;
begin
  b := Null;

  Check(b >= Null);

  s := 'aaa';
  b := 'aab';
  s2 := 'aac';

  CheckFalse(b >= Null);

  CheckTrue(b >= s);
  CheckTrue(b >= b);
  CheckFalse(b >= s2);
end;

procedure OLIntegerTest.LessInteger;
var
  b: OLInteger;
begin
  b := 3;

  CheckFalse(b < 3);
  CheckTrue(b < 3.1);
end;

procedure OLStringTest.LessString;
var
  b: OLString;
  s: string;
begin
  CheckFalse(b > Null);

  b := 'asd';
  CheckFalse(b > Null);

  b := 'ÆÆÆ';
  s := 'DDD';
  CheckFalse(b < s); //'ÆÆÆ' is greater then 'D' (!)

  b := 'CCC';
  s := 'DDD';
  Check(b < s);

  CheckFalse(b < b);
end;

procedure OLStringTest.LinesString;
var
  b: OLString;
  TestFileName: string;
begin
  Check(b.LineCount = 1); //Empty string

  b.LineAdd('First line');
  b.LineAdd('Some line');
  Check(b.LineCount = 2);

  Check(b.Lines[1] = 'Some line');

  b.LineInsertAt(1, 'Second line');

  Check(b.Lines[0] = 'First line');
  Check(b.Lines[1] = 'Second line');
  Check(b.Lines[2] = 'Some line');

  b.Lines[2] := 'Third line';

  Check(b.Lines[2] = 'Third line');

  Check(b.LineIndexOf('Second line') = 1);

  b.LineDelete(1);
  Check(b.LineIndexOf('Second line') = -1);


  TestFileName := GetTemp() + 'test.txt';
  b.SaveToFile(TestFileName);

  b := '';

  b.LoadFromFile(TestFileName);
  DeleteFile(TestFileName);

  Check(b.Lines[1] = 'Third line');

  b := '';
  b.LineAdd('');
  b.LineAdd('Second line');
  Check(b.Lines[1] = 'Second line');

  b := '';
  b.LineAdd('');
  b.LineAdd('');
  b.LineAdd('Third line');
  Check(b.Lines[2] = 'Third line');

  b := Null;

  Check(b.LineCount.IsNull());
end;

procedure OLStringTest.LowerUpperCaseString;
var
  b: OLString;
begin
  b := 'James Bond';

  Check(b.UpperCase() = 'JAMES BOND');
  Check(b.LowerCase() = 'james bond');

  b := 'james bond';
  Check(b.InitCaps() = 'James Bond');

  b := 'jAMES boND';
  Check(b.InitCaps() = 'James Bond');
end;

procedure OLIntegerTest.LessEqualInteger;
var
  b: OLInteger;
begin
  CheckTrue(b >= Null);

  b := 3;

  CheckFalse(b <= 2.5);
  CheckTrue(b <= 3);

  b := -2;
  CheckTrue(b <= -2);
end;

procedure OLStringTest.LastDelimiterString;
var
  b: OLString;
begin
  b := '123_567_90';
  Check(b.LastDelimiterPosition('_') = 8);
end;

procedure OLStringTest.LeadTrailAddString;
var
  b: OLString;
begin
  b := '1234';
  Check(b.LeadingCharsAdded('-', 7) = '---1234');
  Check(b.LeadingSpacesAdded(8) = '    1234');
  Check(b.LeadingZerosAdded(6) = '001234');

  Check(b.TrailingCharsAdded('-', 7) = '1234---');
  Check(b.TrailingSpacesAdded(8) = '1234    ');
end;

procedure OLStringTest.LeftRightString;
var
  b: OLString;
begin
  b := '1234KaBoom';
  Check(b.LeftStr(3) = '123');
  Check(b.RightStr(4) = 'Boom');
  Check(b.RightStrFrom(5) = 'KaBoom');
  Check(b.EndingRemoved(5) = '1234K');
end;

procedure OLStringTest.LengthString;
var
  b: OLString;
begin
  CheckFalse(b.Length().IsNull());

  b := Null;
  Check(b.Length().IsNull());

  b := '';
  Check(b.Length() = 0);

  b := 'Agnieszka';
  Check(b.Length = 9);
end;

procedure OLStringTest.LessEqualString;
var
  b: OLString;
  s, s2: string;
begin
  CheckFalse(b <= Null);

  b := Null;

  Check(b <= Null);

  s := 'ZZa';
  b := 'ZZx';
  s2 := 'ZZz';

  CheckFalse(b <= Null);

  CheckTrue(b <= s2);
  CheckTrue(b <= b);
  CheckFalse(b <= s);
end;

procedure OLIntegerTest.NotEqualInteger;
var
  b: OLInteger;
begin
  CheckFalse(b <> Null);

  b := 3;

  CheckTrue(b <> Null);

  CheckTrue(b <> -1.1);
  CheckFalse(b <> 3);
end;

procedure OLStringTest.NotEqualString;
var
  b: OLString;
  s: string;
begin
  Check(b <> Null);

  b := Null;

  CheckFalse(b <> Null);

  b := 'ZZZZZ';
  s := 'AAAA';

  CheckTrue(b <> Null);

  CheckTrue(b <> s);
  CheckFalse(b <> b);
end;

procedure OLStringTest.OccurrancesString;
var
  b: OLString;
begin
  b := 'My name is Bond. My name is Bond. My name is Bond. My name is Bond.';

  Check(b.OccurrencesCount('Bond') = 4);
  Check(b.OccurrencesCount('bond') = 0);
  Check(b.OccurrencesCount('bond', csCaseInsensitive) = 4);

  Check(b.OccurrencesPosition('Bond', 1) = 12);
  Check(b.OccurrencesPosition('Bond', 2) = 29);
  Check(b.OccurrencesPosition('Bond', 3) = 46);
  Check(b.OccurrencesPosition('Bond', 4) = 63);


  Check(b.OccurrencesPosition('bond', 4, csCaseInsensitive) = 63);
end;

procedure OLStringTest.PositionString;
var
  b: OLString;
  i: OLInteger;
begin
  b := 'My name is Bond. My name is James Bond.';

  i := b.Pos('Bond');
  Check(i = 12);

  i := b.PosEx('Bond', i + 1);
  Check(i = 35);

  i := b.Pos('bond', csCaseInsensitive);
  Check(i = 12);

  i := b.PosEx('bond', i + 1, csCaseInsensitive);
  Check(i = 35);
end;

procedure OLStringTest.QuotedString;
var
  b: OLString;
begin
  b := 'Quo Vadis';
  Check(b.QuotedStr() = QuotedStr(b));
end;

procedure OLStringTest.ReplaceString;
var
  b: OLString;
  i: OLInteger;
begin
  b := 'My name is Bond. My name is James Bond.';
  b := b.Replaced('Bond', 'Bean');
  Check(b = 'My name is Bean. My name is James Bean.');

  b := 'My name is Bond. My name is James Bond.';
  b := b.ReplacedFirst('Bond', 'Bean');
  Check(b = 'My name is Bean. My name is James Bond.');

  b := 'My name is Bond. My name is James Bond.';
  b := b.ReplacedText('bond', 'Bean');
  Check(b = 'My name is Bean. My name is James Bean.');

  b := 'My name is Bond. My name is James Bond.';
  b := b.ReplacedFirstText('BOND', 'Bean');
  Check(b = 'My name is Bean. My name is James Bond.');

  b := 'My name is Bond. My name is James Bond.';
  b := b.Replaced('Bond', 'Bean').Replaced('James', 'Johnny');
  Check(b = 'My name is Bean. My name is Johnny Bean.');
end;

procedure OLStringTest.ReverseString;
var
  b: OLString;
begin
  b := 'EVA';

  Check(b.ReversedString() = 'AVE');
end;

procedure OLDateTimeTest.NowDateTime;
var
  b: OLDateTime;
begin
  b.SetNow();

  Check(b = Now());
end;

procedure OLIntegerTest.SetInteger;
var
  b: OLInteger;
begin
  b := 1;
  Check(b = 1);

  b := 0;
  Check(b = 0);

  b := '-100';
  Check(b = -100);
end;

procedure OLIntegerTest.SetRandomPrimeInteger;
var
  b: OLInteger;
begin
  b.SetRandomPrime(1000, 100000);
  Check(b.IsPrime() and (b >= 1000) and (b <= 100000), b.ToString());

  b.SetRandomPrime(5000);
  Check(b.IsPrime() and (b <= 5000), b.ToString());
end;

procedure OLStringTest.SameString;
var
  b: OLString;
begin
  b := 'Quo Vadis';

  Check(b.SameStr('Quo ' + 'Vadis'));
  CheckFalse(b.SameStr('quo vadis'));
  Check(b.SameText('quo vadis'));
end;

procedure OLStringTest.SetString;
var
  b: OLString;
  s: string;
  s2: string;
begin
  s := 'Hanna';

  b := s;
  Check(b = s);

  //Change a char in a string using index
  b[1] := 'P'; // Hanna -> Panna
  Check(b = 'Panna');

  s := 'Kasia';
  b := s;
  Check(b = s);
  CheckFalse(b = 'kasia');

  // assigning TDate to OLString - automatic conversion to string
  b := EncodeDate(2017,5,8);
  s := DateToStr(EncodeDate(2017,5,8));
  Check(b = s);

  // assigning float number to OLString - automatic conversion to string
  b := 47123.5;
  Check(b = FloatToStr(47123.5));
end;

procedure OLStringTest.SmartToDateString;
var
  b : OLString;

begin
  b := 'td';
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today());

  b := 't';
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today());

  b := 'y';
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Yesterday());

  b := 'yd';
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Yesterday());

  b := 'tm';
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Tomorrow());

  b := 'by'; // Beginning of the year
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().StartOfTheYear());

  b := 'ey'; // End of the year
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().EndOfTheYear());

  b := 'bm';  // Beginning of the month
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().StartOfTheMonth());

  b := 'em'; // End of the month
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().EndOfTheMonth());

  b := 'bny'; // Beginning of the next year
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().IncYear().StartOfTheYear());

  b := 'eny'; // End of the next year
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().IncYear().EndOfTheYear());

  b := 'bnm'; // Beginning of the next month
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().IncMonth().StartOfTheMonth());

  b := 'enm'; // End of the next month
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().IncMonth().EndOfTheMonth());

  b := 'bpy'; // Beginning of the prior year
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().IncYear(-1).StartOfTheYear());

  b := 'epy'; // End of the prior year
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().IncYear(-1).EndOfTheYear());

  b := 'bpm'; // Beginning of the prior month
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().IncMonth(-1).StartOfTheMonth());

  b := 'epm'; // End of the prior month
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().IncMonth(-1).EndOfTheMonth());

  b := '5'; // Day
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().RecodedDay(5));

  b := '26'; // Day
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().RecodedDay(26));

  b := '426'; // Month + Day
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().RecodedMonth(4).RecodedDay(26));

  b := '1126'; // Month + Day
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().RecodedMonth(11).RecodedDay(26));

  b := '81126'; // Year + Month + Day
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().RecodedYear(2008).RecodedMonth(11).RecodedDay(26));

  b := '80106'; // Year + Month + Day
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().RecodedYear(2008).RecodedMonth(1).RecodedDay(6));

  b := '161126'; // Year + Month + Day
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().RecodedYear(2016).RecodedMonth(11).RecodedDay(26));

  b := '1161126'; // Year + Month + Day
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().RecodedYear(2116).RecodedMonth(11).RecodedDay(26));

  b := '20151126'; // Full Year + Month + Day
  Check(b.TrySmartStrToDate());
  Check(b.SmartStrToDate() = OLDate.Today().RecodedYear(2015).RecodedMonth(11).RecodedDay(26));
end;

procedure OLStringTest.SplitString;
var
  b: OLString;
  lst: TStringDynArray;
begin
  b := 'One;Two;Three;Four';
  lst := b.SplitString();

  Check(lst[0] = 'One');
  Check(lst[1] = 'Two');
  Check(lst[2] = 'Three');
  Check(lst[3] = 'Four');

  b := 'Four,Three,Two,One';
  lst := b.SplitString(',');

  Check(lst[0] = 'Four');
  Check(lst[2] = 'Two');
  Check(lst[1] = 'Three');
  Check(lst[3] = 'One');
end;

procedure OLStringTest.StartsEndsString;
var
  b: OLString;
begin
  b := 'One Two Three Four';

  Check(b.StartsStr('One'));
  CheckFalse(b.StartsStr('one'));
  Check(b.StartsText('ONE'));

  Check(b.EndsStr('Four'));
  CheckFalse(b.EndsStr('four'));
  Check(b.EndsText('four'));
end;

procedure OLDateTest.TodayDate;
var
  b: OLDate;
begin
  b.SetToday();
  Check(b = Today());

  Check(OLDate.Today = Today());
end;

procedure OLDateTimeTest.TodayDateTime;
var
  b: OLDateTime;
begin
  b.SetToday();
  Check(b = Today());

  Check(OLDateTime.Today = Today());
end;

procedure OLDateTest.TomorrowDate;
var
  b: OLDate;
begin
  b.SetTomorow();
  Check(b = Tomorrow());

  Check(OLDate.Tomorrow = Tomorrow());
end;

procedure OLDateTimeTest.TomorrowDateTime;
var
  b: OLDateTime;
begin
  b.SetTomorrow();
  Check(b = Tomorrow());

  Check(OLDateTime.Tomorrow = Tomorrow());
end;

procedure OLIntegerTest.IsNullInteger;
var
  b: OLInteger;
begin
  Check(b.IsNull());

  b := 1;
  Check(b.IsNull() = False);

  b := Null;
  Check(b.IsNull());
end;

procedure OLStringTest.IBANString;
var
  b: OLString;
begin
  b := 'PL86101014690004882221000000';
  Check(b.IsValidIBAN());

  //Country code is obligatory
  b := '86101014690004882221000000';
  CheckFalse(b.IsValidIBAN());

  //IBAN number can contain spaces. They are removed prior the validation
  b := 'PL 86 1010 1469 0004 8822 2100 0000';
  Check(b.IsValidIBAN());

  b := 'PL 86 1010 1469 0004 8822 2100 0001';
  CheckFalse(b.IsValidIBAN());
end;

procedure OLStringTest.IncludeExcludeFinalCharString;
var
  b: OLString;
begin
  b := 'c:\temp\';
  Check(b.TrailingPathDelimiterExcluded() = 'c:\temp');
  b := 'c:\temp';
  Check(b.TrailingPathDelimiterExcluded() = 'c:\temp');

  b := 'c:\asd';
  Check(b.TrailingPathDelimiterIncluded() = 'c:\asd\');
  b := 'c:\asd\';
  Check(b.TrailingPathDelimiterIncluded() = 'c:\asd\');

  b := '1;2;3;';
  Check(b.TrailingCharExcluded(';') = '1;2;3');
  b := '1;2;3';
  Check(b.TrailingCharExcluded(';') = '1;2;3');

  b := '4|5|6';
  Check(b.TrailingCharIncluded('|') = '4|5|6|');
  b := '4|5|6|';
  Check(b.TrailingCharIncluded('|') = '4|5|6|');

  b := '7,8,9';
  Check(b.TrailingComaIncluded() = '7,8,9,');
  b := '7,8,9,';
  Check(b.TrailingComaIncluded() = '7,8,9,');

  b := '7,8,9';
  Check(b.TrailingComaExcluded() = '7,8,9');
  b := '7,8,9,';
  Check(b.TrailingComaExcluded() = '7,8,9');
end;

procedure OLStringTest.IndexString;
var
  b: OLString;
begin
  b := 'Three';

  Check(b.IndexStr(['One', 'Two', 'Three']) = 2);
  Check(b.IndexStr(['one', 'two', 'three']) = -1);

  Check(b.IndexText(['one', 'two', 'three']) = 2);
end;

procedure OLStringTest.InsertDeleteString;
var
  b: OLString;
begin
  b := 'My name is Bond. Bond.';

  b := b.Inserted('James ', 18);
  Check(b = 'My name is Bond. James Bond.');

  b := b.Deleted(17, 12);
  Check(b = 'My name is Bond.');

  b := b.Inserted('Hello. ', 1);
  Check(b = 'Hello. My name is Bond.');

  b := '123456789';
  b := b.Deleted(4,3);
  Check(b = '123789');
end;

procedure OLStringTest.IsNullString;
var
  b: OLString;
begin
  CheckFalse(b.IsNull());

  b := 'Agnieszka';
  CheckFalse(b.IsNull());

  b := Null;
  Check(b.IsNull());
end;

procedure OLDateTest.IsTodayDate;
var
  b: OLDate;
begin
  b := Now();
  Check(b.IsToday());

  b := Tomorrow();
  CheckFalse(b.IsToday());
end;

procedure OLDateTimeTest.IsTodayDateTime;
var
  b: OLDateTime;
begin
  b := Now();
  Check(b.IsToday());

  b := Tomorrow();
  CheckFalse(b.IsToday());
end;

procedure OLDoubleTest.IsZeroDouble;
var
  b: OLDouble;
begin
  b := 0;
  Check(b.IsZero());
  b := 0.09999;
  Check(b.IsZero(0.1));
  CheckFalse(b.IsZero());
end;

procedure OLIntegerTest.ToStringInteger;
var
  b: OLInteger;
begin
  b := 123;
  CheckEqualsString('123', b.ToString());

  b := -100123;
  CheckEqualsString('-100123', b.ToString());
end;


procedure OLStringTest.ConvertString;
var
  b: OLString;

  dt: TDateTime;
  c: Currency;
  d: Double;
  i: Integer;
  i64: Int64;
  dt2: TDateTime;
  dat: TDate;

  olc: OLCurrency;
  old: OLDouble;
  oli: OLInteger;
  oldt2: OLDateTime;
  oldat: OLDate;
begin
  b := CurrToStr(2.55);
  Check(b.TryToCurr());
  Check(b.ToCurr() = 2.55);
  Check(b.TryToCurr(c));
  Check(c = 2.55);
  Check(b.TryToCurr(olc));
  Check(olc = 2.55);

  b := FloatToStr(2.55);
  Check(b.TryToFloat());
  Check(b.ToFloat() = 2.55);
  Check(b.TryToFloat(d));
  Check(abs(d - 2.55) < 1e-5);
  Check(b.TryToFloat(old));
  Check(old = 2.55);

  b := '255';
  Check(b.TryToInt());
  Check(b.ToInt() = 255);
  Check(b.TryToInt(i));
  Check(i = 255);
  Check(b.TryToInt(oli));
  Check(oli = 255);

  b := '255000000000000000';
  Check(b.TryToInt64());
  Check(b.ToInt64 = 255000000000000000);
  Check(b.TryToInt64(i64));
  Check(i64 = 255000000000000000);

  dt := Now;
  dt := RecodeMilliSecond(now, 0); //No milliseconds in string
  b := DateTimeToStr(dt);
  Check(b.TryToDateTime());
  Check(b.ToDateTime() = dt);
  Check(b.TryToDateTime(dt2));
  Check(dt2 = dt);
  Check(b.TryToDateTime(oldt2));
  Check(oldt2 = dt);

  dat := Date();
  b := DateToStr(dat);
  Check(b.TryToDate());
  Check(b.ToDate() = dat);
  Check(b.TryToDate(dt2));
  Check(dt2 = dat);
  Check(b.TryToDate(oldat));
  Check(oldat = dat);
end;

procedure OLStringTest.ToStringString;
var
  b: OLString;
begin
  Check(b.ToString() = '');

  b := 'Agnieszka';
  Check(b = b.ToString());
end;

procedure OLStringTest.TrimmedString;
var
  b: OLString;
begin
  b := ' BOND ';
  Check(b.Trimed() = 'BOND');
  Check(b.TrimedLeft() = 'BOND ');
  Check(b.TrimedRight() = ' BOND');
end;

procedure OLDateTest.WeeksInYearDate;
var
  b: OLDate;
  d: TDate;
  i: integer;
begin
  for i := 2000 to 2020 do
  begin
    d := EncodeDate(i,1,10);
    b := d;
    Check(b.WeeksInYear = WeeksInYear(d));
  end;
end;

procedure OLDateTimeTest.WeeksInYearDateTime;
var
  b: OLDateTime;
  dt: TDateTime;
  i: integer;
begin
  for i := 2000 to 2020 do
  begin
    dt := EncodeDateTime(i,1,10,10,10,10,100);
    b := dt;
    Check(b.WeeksInYear = WeeksInYear(dt));
  end;
end;

procedure OLCurrencyTest.EqualsCurrency;
var
  b: OLCurrency;
begin
  CheckTrue(b = Null);

  b := 3.52;

  CheckFalse(b = Null);

  CheckTrue(b = 3.52);
  CheckFalse(b = 1.1);
  CheckFalse(b = -1.2);
  CheckFalse(b = 0);
  CheckFalse(b = 3.521);

  b := 1.11115;
  Check(b = 1.1112);
end;

procedure OLDoubleTest.EqualsDouble;
var
  b: OLDouble;
begin
  CheckTrue(b = Null);

  b := 3.52;

  CheckFalse(b = Null);

  CheckTrue(b = 3.52);
  CheckFalse(b = 1.1);
  CheckFalse(b = -1.2);
  CheckFalse(b = 0);
  CheckFalse(b = 3.521);

  b := -1.11115;
  Check(b = -1.11115);

  b := 0;
  Check(b = 0);
end;

procedure OLCurrencyTest.GreaterCurrency;
var
  b: OLCurrency;
begin
  b := 3.01;

  CheckFalse(b > Null);

  CheckTrue(b > 2.1);
  CheckFalse(b > 3.01);
  CheckFalse(b > 4);
end;

procedure OLCurrencyTest.GreaterEqualCurrency;
var
  b: OLCurrency;
begin
  b := 3.0001;

  CheckFalse(b >= Null);

  CheckTrue(b >= 2.1);
  CheckTrue(b >= 3.0001);
  CheckFalse(b >= 3.0002);

  b := -3;
  CheckFalse(b >= -2.9999);
end;

procedure OLCurrencyTest.LessCurrency;
var
  b: OLCurrency;
begin
  b := 3.1111;

  CheckFalse(b < 3.1111);
  CheckTrue(b < 3.1112);
  CheckTrue(b < 3.11111);
end;

procedure OLCurrencyTest.LessEqualCurrency;
var
  b: OLCurrency;
begin
  b := 3.9999;

  CheckFalse(b <= 2.522);
  CheckTrue(b <= 3.9999);

  b := -2.1234;
  CheckTrue(b <= -2.1234);
end;

procedure OLCurrencyTest.NotEqualCurrency;
var
  b: OLCurrency;
begin
  CheckFalse(b <> Null);

  b := 3.1234;

  CheckTrue(b <> Null);

  CheckTrue(b <> -1.1);
  CheckFalse(b <> 3.1234);
  CheckTrue(b <> 3.12339);
end;

procedure OLCurrencyTest.SetCurrency;
var
  b: OLCurrency;
begin
  b := 1;
  Check(b = 1);

  b := 0;
  Check(b = 0);

  b := '-100';
  Check(b = -100);

  b := 1.12349;
  Check(b = 1.1235);
end;

procedure OLCurrencyTest.IsNullCurrency;
var
  b: OLCurrency;
begin
  Check(b.IsNull());

  b := 1.0001;
  Check(b.IsNull() = False);

  b := Null;
  Check(b.IsNull());
end;

procedure OLCurrencyTest.ToStringCurrency;
var
  b: OLCurrency;
begin
  Check(b.ToString() = EmptyStr);

  b := 123;
  CheckEqualsString(CurrToStrF(123, ffCurrency, 2) , b.ToString());

  b := -100123;
  CheckEqualsString(CurrToStrF(-100123, ffCurrency, 2), b.ToString());
end;

procedure OLCurrencyTest.IfNullCurrency;
var
  b: OLCurrency;
begin
  Check(b.IfNull(1.1) = 1.1);

  b := -1.0001;
  Check(b.IfNull(1) = -1.0001);

  b := null;
  Check(b.IfNull(-5.22) = -5.22);
end;

procedure OLDoubleTest.GreaterDouble;
var
  b: OLDouble;
begin
  b := 3.011;

  CheckFalse(b > Null);

  CheckTrue(b > 2.1);
  CheckFalse(b > 3.011);
  CheckFalse(b > 4.222);
end;

procedure OLDoubleTest.GreaterEqualDouble;
var
  b: OLDouble;
begin
  b := 3.011;

  CheckFalse(b >= Null);

  CheckTrue(b >= 2.1);
  CheckTrue(b >= 3.011);

  b := -3.011;
  CheckFalse(b >= -2.222);
end;

procedure OLDoubleTest.LessDouble;
var
  b: OLDouble;
begin
  b := 3.000003;

  CheckFalse(b < 3.000003);
  CheckTrue(b < 3.1);
end;

procedure OLDoubleTest.LessEqualDouble;
var
  b: OLDouble;
begin
  b := 3.000003;

  CheckFalse(b <= 2.5);
  CheckTrue(b <= 3.000003);

  b := -2.000003;
  CheckTrue(b <= -2.000003);
end;

procedure OLDoubleTest.NotEqualDouble;
var
  b: OLDouble;
begin
  CheckFalse(b <> Null);

  b := 3.000003;

  CheckTrue(b <> Null);

  CheckTrue(b <> -1.1);
  CheckFalse(b <> 3.000003);
end;

procedure OLDoubleTest.SetDouble;
var
  b: OLDouble;
  s: string;
begin
  b := 1;
  Check(b = 1);

  b := 0;
  Check(b = 0);

  b := '-100';
  Check(b = -100);

  b := 1.000003;
  Check(b = 1.000003);

  s := SysUtils.FloatToStr(-100.000003);

  b := s;
  Check(b = -100.000003);
end;

procedure OLDoubleTest.IsNullDouble;
var
  b: OLDouble;
begin
  Check(b.IsNull());

  b := 0.0001;
  Check(b.IsNull() = False);

  b := Null;
  Check(b.IsNull());
end;

procedure OLDoubleTest.ToStringDouble;
var
  b: OLDouble;
begin
  b := 123.00111;
  Check(FloatToStr(123.00111) = b.ToString());
  Check(FloatToStrF(123.00111, ffFixed, 16, 3) = b.ToString(3));

  b := -100123.0243;
  Check(FloatToStr(-100123.0243) = b.ToString());
  Check(FloatToStrF(-100123.0243, ffCurrency, 16, 2) = b.ToString(2, ffCurrency));
end;

procedure OLDoubleTest.IfNullDouble;
var
  b: OLDouble;
begin
  Check(b.IfNull(1.333) = 1.333);

  b := -1.222;
  Check(b.IfNull(1) = -1.222);

  b := null;
  Check(b.IfNull(-5.1) = -5.1);
end;

procedure OLDateTest.EqualsDate;
var
  b, b2: OLDate;
  d: TDate;
begin
  CheckTrue(b = Null);

  b := EncodeDate(2017,5,4);

  CheckFalse(b = Null);

  d := EncodeDate(2017,5,4);

  CheckTrue(b = d);
  CheckFalse(b = Now());

  b := EncodeDateTime(2016,1,10,10,10,10,100);
  b2 := EncodeDate(2016,1,10);
  Check(b = b2);
end;

procedure OLDateTimeTest.EqualsDateTime;
var
  b: OLDateTime;
  dt, dt2: TDateTime;
begin
  CheckTrue(b = Null);

  b := EncodeDateTime(2017,5,4,21,41,50,950);

  CheckFalse(b = Null);

  dt := EncodeDateTime(2017,5,4,21,41,50,950);
  dt2 := Now();

  CheckTrue(b = dt);
  CheckFalse(b = dt2);
end;

procedure OLDateTest.GreaterEqualDate;
var
  b: OLDate;
  d, d2: TDate;
begin
  Check(b >= Null);

  d := EncodeDate(2016,1,1);
  b := EncodeDate(2017,1,1);
  d2 := EncodeDate(2018,1,1);

  CheckFalse(b >= Null);

  CheckTrue(b >= d);
  CheckTrue(b >= b);
  CheckFalse(b >= d2);
end;

procedure OLDateTimeTest.GreaterEqualDateTime;
var
  b: OLDateTime;
  dt, dt2: TDateTime;
begin
  Check(b >= Null);

  dt := Now();
  sleep(10);
  b := Now();
  sleep(10);
  dt2 := Now();

  CheckFalse(b >= Null);

  CheckTrue(b >= dt);
  CheckTrue(b >= b);
  CheckFalse(b >= dt2);
end;

procedure OLDateTest.GreaterDate;
var
  b: OLDate;
  d: TDate;
begin
  CheckFalse(b > Null);

  d := EncodeDate(2016,1,1);
  b := EncodeDate(2017,1,1);

  CheckFalse(b > Null);

  CheckTrue(b > d);
  CheckFalse(b > b);
end;

procedure OLDateTimeTest.GreaterDateTime;
var
  b: OLDateTime;
  dt: TDateTime;
begin
  CheckFalse(b > Null);

  dt := Now();
  sleep(10);
  b := Now();

  CheckFalse(b > Null);

  CheckTrue(b > dt);
  CheckFalse(b > b);
end;

procedure OLDateTest.IsNullDate;
var
  b: OLDate;
begin
  Check(b.IsNull());

  b := Today();
  Check(b.IsNull() = False);

  b := Null;
  Check(b.IsNull());
end;

procedure OLDateTimeTest.IsNullDateTime;
var
  b: OLDateTime;
begin
  Check(b.IsNull());

  b := Now();
  Check(b.IsNull() = False);

  b := Null;
  Check(b.IsNull());
end;

procedure OLDateTest.LessEqualDate;
var
  b: OLDateTime;
  d, d2: TDateTime;
begin
  Check(b <= Null);

  d := EncodeDate(2016,1,1);
  b := EncodeDate(2017,1,1);
  d2 := EncodeDate(2018,1,1);

  CheckFalse(b <= Null);

  CheckTrue(b <= d2);
  CheckTrue(b <= b);
  CheckFalse(b <= d);
end;

procedure OLDateTimeTest.LessEqualDateTime;
var
  b: OLDateTime;
  dt, dt2: TDateTime;
begin
  Check(b <= Null);

  dt := Now();
  sleep(10);
  b := Now();
  sleep(10);
  dt2 := Now();

  CheckFalse(b <= Null);

  CheckTrue(b <= dt2);
  CheckTrue(b <= b);
  CheckFalse(b <= dt);
end;

procedure OLDateTest.LessDate;
var
  b: OLDate;
  d: TDate;
begin
  CheckFalse(b > Null);

  b := EncodeDate(2016,1,1);
  d := EncodeDate(2017,1,1);

  CheckFalse(b > Null);

  CheckTrue(b < d);
  CheckFalse(b < b);
end;

procedure OLDateTimeTest.LessDateTime;
var
  b: OLDateTime;
  dt: TDateTime;
begin
  CheckFalse(b > Null);

  b := Now();
  sleep(10);
  dt := Now();

  CheckFalse(b > Null);

  CheckTrue(b < dt);
  CheckFalse(b < b);
end;

procedure OLDateTest.NotEqualDate;
var
  b: OLDate;
  d: TDate;
begin
  CheckFalse(b <> Null);

  b := EncodeDate(2017,1,1);
  d := EncodeDate(2016,1,1);

  CheckTrue(b <> Null);

  CheckTrue(b <> d);
  CheckFalse(b <> b);
end;

procedure OLDateTimeTest.NotEqualDateTime;
var
  b: OLDateTime;
begin
  CheckFalse(b <> Null);

  b := Now();

  CheckTrue(b <> Null);

  sleep(10);
  CheckTrue(b <> Now());
  CheckFalse(b <> b);
end;

procedure OLDateTest.SetDate;
var
  b: OLDate;
  d: TDate;
  s: string;
begin
  d := Today();

  b := d;
  Check(b = d);

  d := EncodeDate(2017,5,4);
  b := d;
  Check(b = d);
  CheckFalse(b = Today());

  d := EncodeDate(2017,5,8);
  s := DateToStr(d);
  b := s;
  Check(b = d);

  b := 47123.5;
  Check(b = EncodeDate(2029,1,5));
end;

procedure OLDateTimeTest.SetDateTime;
var
  b: OLDateTime;
  dt: TDateTime;
  s: string;
begin
  dt := Now();

  b := dt;
  Check(b = dt);

  dt := EncodeDateTime(2017,5,4,21,58,23,0);
  b := dt;
  Check(b = dt);
  CheckFalse(b = Now());

  s := DateTimeToStr(dt);
  b := s;
  Check(b = dt);

  b := 47123.5;
  Check(b = EncodeDateTime(2029,1,5,12,0,0,0));
end;

procedure OLDateTest.ToStringDate;
var
  b: OLDate;
  d: TDate;
  s: string;
begin
  Check(b.ToString() = '');

  d := Today();

  b := d;
  Check(b.ToString() = DateToStr(d));
end;

procedure OLDateTimeTest.ToStringDateTime;
var
  b: OLDateTime;
  dt: TDateTime;
  s: string;
begin
  Check(b.ToString() = '');

  dt := Now();

  b := dt;
  Check(b.ToString() = DateTimeToStr(dt));
end;

initialization
  // Register any test cases with the test runner
  RegisterTest(OLBooleanTest.Suite);
  RegisterTest(OLIntegerTest.Suite);
  RegisterTest(OLCurrencyTest.Suite);
  RegisterTest(OLDoubleTest.Suite);
  RegisterTest(OLDateTimeTest.Suite);
  RegisterTest(OLDateTest.Suite);
  RegisterTest(OLStringTest.Suite);

end.

