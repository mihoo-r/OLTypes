unit Test_OlTypes;
{

  Delphi DUnit Test Case
  ----------------------
  This unit contains a skeleton test case class generated by the Test Case Wizard.
  Modify the generated code to correctly setup and call the methods from the unit 
  being tested.

}

interface

uses
  TestFramework, Windows, Forms, Dialogs, Controls, Classes, SysUtils, Variants, Graphics,
        Messages, OLTypes;

type
  OLBooleanTest = class(TTestCase)
  published
    procedure SetBoolean;

    procedure EqualsBoolean;
    procedure NotEqualBoolean;
    procedure GreaterBoolean;
    procedure GreaterEqualBoolean;
    procedure LessBoolean;
    procedure LessEqualBoolean;

    procedure IsNullBoolean;
    procedure ToStringBoolean;

    procedure AndBoolean;
    procedure OrBolean;
    procedure NotBoolean;
    procedure XorBoolean;
    procedure IfThenBoolean;
    
    // NULL Handling Tests
    procedure NullHandlingBoolean;
  end;

  OLIntegerTest = class(TTestCase)
  published
    procedure EqualsInteger;
    procedure GreaterEqualInteger;
    procedure GreaterInteger;
    procedure IsNullInteger;
    procedure LessEqualInteger;
    procedure LessInteger;
    procedure NotEqualInteger;
    procedure SetInteger;
    procedure ToStringInteger;

    procedure IsDividableInteger;
    procedure OddEvenInteger;
    procedure PowerInteger;
    procedure PositiveNegativeInteger;
    procedure MaxInteger;
    procedure MinInteger;
    procedure AbsInteger;
    procedure IfNullInteger;
    procedure RoundInteger;
    procedure ForLoopInteger;
    procedure IsPrimeInteger;
    procedure SetRandomPrimeInteger;
    procedure MathOperatorsInteger;
    
    // NULL Propagation Tests
    procedure NullPropagationPredicatesInteger;
    procedure ShortCircuitInteger;
  end;

  OLCurrencyTest = class(TTestCase)
  published
    procedure EqualsCurrency;
    procedure GreaterCurrency;
    procedure GreaterEqualCurrency;
    procedure IfNullCurrency;
    procedure IsNullCurrency;
    procedure LessCurrency;
    procedure LessEqualCurrency;
    procedure NotEqualCurrency;
    procedure SetCurrency;
    procedure ToStringCurrency;

    procedure PowerCurrency;
    procedure PositiveNegativeCurrency;
    procedure MaxCurrency;
    procedure MinCurrency;
    procedure AbsCurrency;
    procedure RoundCurrency;
    procedure MathOperatorsCurrency;
    
    // NULL Propagation Tests
    procedure NullPropagationPredicatesCurrency;
  end;

  OLDoubleTest = class(TTestCase)
  published
    procedure EqualsDouble;
    procedure GreaterDouble;
    procedure GreaterEqualDouble;
    procedure IfNullDouble;
    procedure IsNullDouble;
    procedure LessDouble;
    procedure LessEqualDouble;
    procedure NotEqualDouble;
    procedure SetDouble;
    procedure ToStringDouble;
    procedure MathOperatorsDouble;

    procedure PowerDouble;
    procedure PositiveNegativeDouble;
    procedure MaxDouble;
    procedure MinDouble;
    procedure AbsDouble;
    procedure RoundDouble;
    procedure FloorDouble;
    procedure CeilDouble;
    procedure IsNanDouble;
    procedure IsInfiniteDouble;
    procedure IsZeroDouble;
    procedure InRangeDouble;
    procedure EnsureRangeDouble;
    procedure SameValueDouble;
    
    // NULL Propagation Tests
    procedure NullPropagationPredicatesDouble;
  end;

  OLDateTimeTest = class(TTestCase)
  published
    procedure EqualsDateTime;
    procedure GreaterDateTime;
    procedure GreaterEqualDateTime;
    procedure IsNullDateTime;
    procedure LessDateTime;
    procedure LessEqualDateTime;
    procedure NotEqualDateTime;
    procedure SetDateTime;
    procedure OutPut;
    procedure MathOperatorsDateTime;

    procedure DateOfDateTime;
    procedure TimeOfDateTime;
    procedure IsInLeapYearDateTime;
    procedure AMPMDateTime;
    procedure WeeksInYearDateTime;
    procedure DaysInYearDateTime;
    procedure DaysInMonthDateTime;
    procedure NowDateTime;
    procedure TodayDateTime;
    procedure TomorrowDateTime;
    procedure YesterdayDateTime;
    procedure IsTodayDateTime;
    procedure SameDayDateTime;
    procedure DateTimePartsOfDateTime;
    procedure StartOfEndOfDateTime;
    procedure CountDateTime;
    procedure SpanDateTime;
    procedure IncDateTime;
    procedure RecodingDateTime;
    procedure SameTimeDateTime;
    procedure DateTimePartsDateTime;
    
    // NULL Handling Tests
    procedure NullHandlingDateTime;
  end;

  OLDateTest = class(TTestCase)
  published
    procedure EqualsDate;
    procedure GreaterDate;
    procedure GreaterEqualDate;
    procedure IsNullDate;
    procedure LessDate;
    procedure LessEqualDate;
    procedure NotEqualDate;
    procedure SetDate;
    procedure ToStringDate;
    procedure MathOperatorsDate;

    procedure IsInLeapYearDate;
    procedure WeeksInYearDate;
    procedure DaysInYearDate;
    procedure DaysInMonthDate;
    procedure TodayDate;
    procedure TomorrowDate;
    procedure YesterdayDate;
    procedure IsTodayDate;
    procedure SameDayDate;
    procedure DatePartsOfDate;
    procedure StartOfEndOfDate;
    procedure CountDate;
    procedure SpanDate;
    procedure IncDate;
    procedure RecodingDate;
    procedure DateTimePartsDate;
    
    // NULL Handling Tests
    procedure NullHandlingDate;
  end;

  OLStringTest = class(TTestCase)
  private
    function GetTemp: String;
    function ConnectedToInternet: boolean;
  published
    procedure EqualsString;
    procedure GreaterString;
    procedure GreaterEqualString;
    procedure IsNullString;
    procedure LessString;
    procedure LessEqualString;
    procedure NotEqualString;
    procedure SetString;
    procedure ToStringString;
    procedure MathOperatorsString;

    procedure GetLineStartPositionString;
    procedure CSVFieldValueString;
    procedure LengthString;
    procedure ContainsString;
    procedure DupeString;
    procedure StartsEndsString;
    procedure IndexString;
    procedure MatchString;
    procedure MidStrString;
    procedure FindPatternString;
    procedure PositionString;
    procedure ReplaceString;
    procedure ReverseString;
    procedure LeftRightString;
    procedure SplitString;
    procedure InsertDeleteString;
    procedure FilePathExtract;
    procedure FormatString;
    procedure LastDelimiterString;
    procedure LowerUpperCaseString;
    procedure TrimmedString;
    procedure QuotedString;
    procedure SameString;
    procedure DigitsOnlyNoSpacesString;
    procedure LeadTrailAddString;
    procedure ConvertString;
    procedure SmartToDateString;
    procedure Base64String;
    procedure CompressionString;
    procedure IncludeExcludeFinalCharString;
    procedure OccurrancesString;
    procedure LinesString;
    procedure HashString;
    procedure GetFromURLString;
    procedure IBANString;

    // Null Handling & Basic Operations
    procedure IfNullOrEmptyString;
    procedure IsNullOrEmptyString;
    procedure NotNullNorEmptyString;
    procedure IsEmptyStrString;

    // Character Manipulation
    procedure AlphanumericsOnlyString;
    procedure NoDigitsString;
    procedure RepeatedStringString;
    procedure LikeString;

    // String Pattern Finding
    procedure FindTagStrString;
    procedure FindPatternStrString;

    // Leading Character Operations
    procedure LeadingCharString;
    procedure LeadingComaString;
    procedure LeadingApostropheString;

    // Trailing Apostrophe Operations
    procedure TrailingApostropheString;

    // URL & HTML Encoding
    procedure UrlEncodedTextString;
    procedure HtmlUnicodeTextString;

    // Position & Replacement Operations
    procedure ReplacedStartingAtString;
    procedure PosLastString;

    // CSV Operations Advanced
    procedure CSVIndexString;
    procedure CSVFieldNameString;
    procedure CSVFieldByNameString;

    // Parameter & JSON Operations
    procedure ParamsString;
    {$IF CompilerVersion >= 27.0}
    procedure JSONString;
    {$IFEND}

    // Static Methods
    procedure RandomFromString;
    procedure RandomStringString;

    // Line Operations
    procedure LinesSortedString;
    procedure LineIndexLikeString;

    // Conversion & Utility
    procedure ToSQLStringString;
    procedure ToPWideCharString;
    procedure LineEndAtString;
    
    // NULL Handling Tests
    procedure NullHandlingString;
  end;

implementation

uses DateUtils, Math, Types, WinInet;

procedure OLCurrencyTest.AbsCurrency;
var
  c: OLCurrency;
begin
  c := -5.1234;
  Check(c.Abs() = 5.1234);
  c := 0;
  Check(c.Abs() = 0);
  c := 1.1234;
  Check(c.Abs() = 1.1234);
end;

procedure OLDoubleTest.AbsDouble;
var
  d: OLDouble;
begin
  d := -5.1234;
  Check(d.Abs() = 5.1234);
  d := 0;
  Check(d.Abs() = 0);
  d := 1.1234;
  Check(d.Abs() = 1.1234);
end;

procedure OLIntegerTest.AbsInteger;
var
  i: OLInteger;
begin
  i := -5;
  Check(i.Abs() = 5);
  i := 0;
  Check(i.Abs() = 0);
  i := 1;
  Check(i.Abs() = 1);
end;

procedure OLDateTimeTest.AMPMDateTime;
var
  dt: OLDateTime;
begin
  dt := EncodeDateTime(2016,1,10,10,10,10,100);
  Check(dt.IsAM());
  CheckFalse(dt.IsPM);

  dt := EncodeDateTime(2017,1,10,23,10,10,100);
  CheckFalse(dt.IsAM());
  Check(dt.IsPM);
end;

procedure OLBooleanTest.AndBoolean;
var
  b: OLBoolean;
begin
  b := true;

  CheckTrue(b and true);
end;

procedure OLDoubleTest.CeilDouble;
var
  d: OLDouble;
begin
  d := 123.149;
  Check(d.Ceil() = 124);

  d := -123.149;
  Check(d.Ceil() = -123);
end;


procedure OLDateTest.CountDate;
var
  d: OLDate;
begin
  d.SetToday();

  Check(d.DayOfTheYear() = DayOfTheYear(d));
  Check(d.DayOfTheWeek() = DayOfTheWeek(d));
end;

procedure OLDateTimeTest.CountDateTime;
var
  dt, dt2: OLDateTime;
  i: OLInteger;
begin
  dt.SetNow();

  Check(dt.DayOfTheYear() = DayOfTheYear(dt));
  Check(dt.HourOfTheYear() = HourOfTheYear(dt));
  Check(dt.MinuteOfTheYear() = MinuteOfTheYear(dt));
  Check(dt.SecondOfTheYear() = SecondOfTheYear(dt));
  Check(dt.MilliSecondOfTheYear() = MilliSecondOfTheYear(dt));

  Check(dt.HourOfTheMonth() = HourOfTheMonth(dt));
  Check(dt.MinuteOfTheMonth() = MinuteOfTheMonth(dt));
  Check(dt.SecondOfTheMonth() = SecondOfTheMonth(dt));
  Check(dt.MilliSecondOfTheMonth() = MilliSecondOfTheMonth(dt));

  Check(dt.DayOfTheWeek() = DayOfTheWeek(dt));
  Check(dt.HourOfTheWeek() = HourOfTheWeek(dt));
  Check(dt.MinuteOfTheWeek() = MinuteOfTheWeek(dt));
  Check(dt.SecondOfTheWeek() = SecondOfTheWeek(dt));
  Check(dt.MilliSecondOfTheWeek() = MilliSecondOfTheWeek(dt));

  Check(dt.MinuteOfTheDay() = MinuteOfTheDay(dt));
  Check(dt.SecondOfTheDay() = SecondOfTheDay(dt));
  Check(dt.MilliSecondOfTheDay() = MilliSecondOfTheDay(dt));

  Check(dt.SecondOfTheHour() = SecondOfTheHour(dt));
  Check(dt.MilliSecondOfTheHour() = MilliSecondOfTheHour(dt));

  Check(dt.MilliSecondOfTheMinute() = MilliSecondOfTheMinute(dt));

  dt.SetNow();
  dt := dt.RecodedMilliSecond(0);
  i := OLDateTime.SecondCount();
  dt2 := OLDateTime.DateTimeFromSecondCount(i);
  Check(dt2 = dt);
end;

procedure OLDateTimeTest.DateOfDateTime;
var
  dt: OLDateTime;
begin
  dt := Now();

  Check(dt.DateOf() = Date());
end;

procedure OLDateTest.DatePartsOfDate;
var
  d: OLDate;
begin
  d := EncodeDate(2017,1,10);

  Check(d.Year = 2017);
  Check(d.Month = 1);
  Check(d.Day = 10);
end;

procedure OLDateTest.DateTimePartsDate;
var
  d, d2: OLDate;
begin
  d.SetToday;

  d2.SetToday;
  d2.Year := 2000 ;
  Check(d.RecodedYear(2000) = d2);

  d2.SetToday;
  d2.Month := 12 ;
  Check(d.RecodedMonth(12) = d2);

  d2.SetToday;
  d2.Day := 6 ;
  Check(d.RecodedDay(6) = d2);
end;

procedure OLDateTimeTest.DateTimePartsDateTime;
var
  dt, dt2: OLDateTime;
begin
  dt.SetToday;

  dt2.SetToday;
  dt2.Year := 2000 ;
  Check(dt.RecodedYear(2000) = dt2);

  dt2.SetToday;
  dt2.Month := 12 ;
  Check(dt.RecodedMonth(12) = dt2);

  dt2.SetToday;
  dt2.Day := 6 ;
  Check(dt.RecodedDay(6) = dt2);

  dt2.SetToday;
  dt2.Hour := 6 ;
  Check(dt.RecodedHour(6) = dt2);

  dt2.SetToday;
  dt2.Minute := 15 ;
  Check(dt.RecodedMinute(15) = dt2);

  dt2.SetToday;
  dt2.Second := 52 ;
  Check(dt.RecodedSecond(52) = dt2);

  dt2.SetToday;
  dt2.MilliSecond := 572 ;
  Check(dt.RecodedMilliSecond(572) = dt2);
end;

procedure OLDateTimeTest.DateTimePartsOfDateTime;
var
  dt: OLDateTime;
begin
  dt := EncodeDateTime(2017,1,10,9,38,15,100);

  Check(dt.Year = 2017);
  Check(dt.Month = 1);
  Check(dt.Day = 10);
  Check(dt.Hour = 9);
  Check(dt.Minute = 38);
  Check(dt.Second = 15);
  Check(dt.MilliSecond = 100);
end;

procedure OLDateTest.DaysInMonthDate;
var
  d: OLDate;
  dt: TDate;
  i: integer;
begin
  dt := EncodeDate(2017,1,10);

  for i := 1 to 20 do
  begin
    dt := IncMonth(dt);
    d := dt;
    Check(d.DaysInMonth = DaysInMonth(dt));
  end;
end;

procedure OLDateTimeTest.DaysInMonthDateTime;
var
  dt: OLDateTime;
  dtt: TDateTime;
  i: integer;
begin
  dtt := EncodeDateTime(2017,1,10,10,10,10,100);

  for i := 1 to 20 do
  begin
    dtt := IncMonth(dtt);
    dt := dtt;
    Check(dt.DaysInMonth = DaysInMonth(dtt));
  end;
end;

procedure OLDateTest.DaysInYearDate;
var
  d: OLDate;
  dt: TDate;
  i: integer;
begin
  for i := 2000 to 2020 do
  begin
    dt := EncodeDate(i,1,10);
    d := dt;
    Check(d.DaysInYear = DaysInYear(dt));
  end;
end;

procedure OLDateTimeTest.DaysInYearDateTime;
var
  dt: OLDateTime;
  dtt: TDateTime;
  i: integer;
begin
  for i := 2000 to 2020 do
  begin
    dtt := EncodeDateTime(i,1,10,10,10,10,100);
    dt := dtt;
    Check(dt.DaysInYear = DaysInYear(dtt));
  end;
end;

procedure OLDoubleTest.EnsureRangeDouble;
var
  d: OLDouble;
begin
  d := 0;
  d := d.EnsureRange(5.5, 10);
  Check(d = 5.5);

  d := d.EnsureRange(-100, -1.0001);
  Check(d = -1.0001);
end;

procedure OLBooleanTest.EqualsBoolean;
var
  b: OLBoolean;
begin
  CheckTrue(b = Null);

  b := True;

  CheckFalse(b = Null);

  CheckTrue(b = True);
  CheckFalse(b = False);
end;

procedure OLBooleanTest.GreaterBoolean;
var
  b: OLBoolean;
begin
  CheckFalse(b > Null);

  b := true;

  CheckFalse(b > Null);

  CheckTrue(b > False);
  CheckFalse(b > True);
end;

procedure OLBooleanTest.GreaterEqualBoolean;
var
  b: OLBoolean;
begin
  CheckTrue(b >= Null);

  b := True;

  CheckFalse(b >= Null);

  CheckTrue(b >= False);
  CheckTrue(b >= True);

  b := False;
  CheckFalse(b >= True);
end;

procedure OLIntegerTest.IsPrimeInteger;
var
  i: OLInteger;
begin
  i := 0;

  CheckFalse(i.IsPrime());

  i := 1984441079;
  Check(i.IsPrime(), '1984441079 should be prime');

  i := 97496039;
  Check(i.IsPrime(), '97496039 should be prime');

  i := 97496033;
  CheckFalse(i.IsPrime(), '97496033 should not be prime');

  i := 2;
  Check(i.IsPrime(), '2 should be prime');

  i := 3;
  Check(i.IsPrime(), '3 should be prime');

  i := 1;
  CheckFalse(i.IsPrime(), '1 should not be prime');

  i := 0;
  CheckFalse(i.IsPrime(), '0 should not be prime');

  i := -5;
  CheckFalse(i.IsPrime(), '-5 should not be prime');

  i := 4;
  CheckFalse(i.IsPrime(), '4 should not be prime');

  i := 29;
  Check(i.IsPrime(), '29 should be prime');
end;

procedure OLIntegerTest.IfNullInteger;
var
  i: OLInteger;
begin
  Check(i.IfNull(1) = 1);

  i := -1;
  Check(i.IfNull(1) = -1);

  i := null;
  Check(i.IfNull(-5) = -5);
end;

procedure OLBooleanTest.IfThenBoolean;
var
  b: OLBoolean;
  c1, c2: Currency;
begin
  b := False;

  Check(b.IfThen(1, 2) = 2);
  Check(b.IfThen(1.1, 2.1) = 2.1);
  Check(b.IfThen(EncodeDate(2000,1,1), EncodeDate(2017, 1, 1)) = EncodeDate(2017, 1, 1));
  Check(b.IfThen(EncodeDateTime(2000,1,1, 12, 0,0,0), EncodeDateTime(2017, 1, 1, 11, 0,0,0)) = EncodeDateTime(2017, 1, 1, 11, 0,0,0));

  c1 := 1.10;
  c2 := 1.20;

  Check(b.IfThen(c1, c2) = c2);

  b := true;

  Check(b.IfThen(1, 2) = 1);
  Check(b.IfThen(1.1, 2.1) = 1.1);
  Check(b.IfThen(EncodeDate(2000,1,1), EncodeDate(2017, 1, 1)) = EncodeDate(2000, 1, 1));
  Check(b.IfThen(EncodeDateTime(2000,1,1, 12, 0,0,0), EncodeDateTime(2017, 1, 1, 11, 0,0,0)) = EncodeDateTime(2000, 1, 1, 12, 0,0,0));

  c1 := 1.10;
  c2 := 1.20;

  Check(b.IfThen(c1, c2) = c1);
end;

procedure OLDateTest.IncDate;
var
  d, d2: OLDate;
begin
  d.EncodeDate(2000, 1,2);

  d2.EncodeDate(2000, 1,8);
  Check(d.IncDay(6) = d2);

  d2.EncodeDate(2000, 1,16);
  Check(d.IncWeek(2) = d2);

  d2.EncodeDate(2000, 3,2);
  Check(d.IncMonth(2) = d2);

  d2.EncodeDate(2004, 1,2);
  Check(d.IncYear(4) = d2);
end;

procedure OLDateTimeTest.IncDateTime;
var
  dt, dt2: OLDateTime;
begin
  dt.EncodeDateTime(2000, 1,2,3,45,25,400);

  dt2.EncodeDateTime(2000, 1,2,3,45,25,500);
  Check(dt.IncMilliSecond(100) = dt2);

  dt2.EncodeDateTime(2000, 1,2,3,45,55,400);
  Check(dt.IncSecond(30) = dt2);

  dt2.EncodeDateTime(2000, 1,2,3,40,25,400);
  Check(dt.IncMinute(-5) = dt2);

  dt2.EncodeDateTime(2000, 1,2,16,45,25,400);
  Check(dt.IncHour(13) = dt2);

  dt2.EncodeDateTime(2000, 1,8,3,45,25,400);
  Check(dt.IncDay(6) = dt2);

  dt2.EncodeDateTime(2000, 1,16,3,45,25,400);
  Check(dt.IncWeek(2) = dt2);

  dt2.EncodeDateTime(2000, 3,2,3,45,25,400);
  Check(dt.IncMonth(2) = dt2);

  dt2.EncodeDateTime(2004, 1,2,3,45,25,400);
  Check(dt.IncYear(4) = dt2);
end;

procedure OLDoubleTest.InRangeDouble;
var
  d: OLDouble;
begin
  d := 0;
  Check(d.InRange(0,100));
  Check(d.InRange(-1,100));
  CheckFalse(d.InRange(1,100));

  d := -0.9999;
  Check(d.InRange(-1,100));
end;

procedure OLIntegerTest.IsDividableInteger;
var
  i: OLInteger;
begin
  i := 5;
  Check(i.IsDividableBy(5));
  CheckFalse(i.IsDividableBy(3));

  i := 6;
  Check(i.IsDividableBy(2));
  Check(i.IsDividableBy(3));
end;

procedure OLDoubleTest.IsInfiniteDouble;
var
  d: OLDouble;
begin
  d := Infinity;
  Check(d.IsInfinite());
end;

procedure OLDateTest.IsInLeapYearDate;
var
  d: OLDate;
begin
  d := EncodeDate(2016,1,10);
  Check(d.IsInLeapYear());

  d := EncodeDate(2017,1,10);
  CheckFalse(d.IsInLeapYear());

  d := EncodeDate(2020,1,10);
  Check(d.IsInLeapYear());
end;

procedure OLDateTimeTest.IsInLeapYearDateTime;
var
  dt: OLDateTime;
begin
  dt := EncodeDateTime(2016,1,10,10,10,10,100);
  Check(dt.IsInLeapYear());

  dt := EncodeDateTime(2017,1,10,10,10,10,100);
  CheckFalse(dt.IsInLeapYear());

  dt := EncodeDateTime(2020,1,10,10,10,10,100);
  Check(dt.IsInLeapYear());
end;

procedure OLDoubleTest.IsNanDouble;
var
  d: OLDouble;
begin
  d := NaN;
  Check(d.IsNan());
end;

procedure OLBooleanTest.IsNullBoolean;
var
  b: OLBoolean;
begin
  Check(b.IsNull());

  b := False;
  Check(b.IsNull() = False);

  b := Null;
  Check(b.IsNull());
end;

procedure OLBooleanTest.LessBoolean;
var
  b: OLBoolean;
begin
  b := False;

  CheckFalse(b < False);
  CheckTrue(b < True);
end;

procedure OLBooleanTest.LessEqualBoolean;
var
  b: OLBoolean;
begin
  b := True;

  CheckFalse(b <= False);
  CheckTrue(b <= True);

  b := False;
  CheckTrue(b <= True);
end;

procedure OLBooleanTest.NotBoolean;
var
  b: OLBoolean;
begin
  b := true;

  CheckFalse(not b);

  b := false;

  CheckTrue(not b);
end;

procedure OLBooleanTest.NotEqualBoolean;
var
  b: OLBoolean;
begin
  CheckFalse(b <> Null);

  b := True;

  CheckTrue(b <> Null);

  CheckTrue(b <> False);
  CheckFalse(b <> True);
end;

procedure OLIntegerTest.OddEvenInteger;
var
  i: OLInteger;
begin
  i := 5;
  Check(i.IsOdd());
  CheckFalse(i.IsEven());

  i := 50000000;
  Check(i.IsEven());
  CheckFalse(i.IsOdd());
end;

procedure OLBooleanTest.OrBolean;
var
  b: OLBoolean;
begin
  b := true;

  CheckTrue(b or False);

  b := False;

  CheckTrue(b or True);
  CheckFalse(b or False);
end;

procedure OLCurrencyTest.PositiveNegativeCurrency;
var
  c: OLCurrency;
begin
  c := 5.0001;
  Check(c.IsPositive());
  CheckFalse(c.IsNegative());
  Check(c.IsNonNegative());

  c := 0;
  CheckFalse(c.IsPositive());
  CheckFalse(c.IsNegative());
  Check(c.IsNonNegative());

  c := -5.0001;
  CheckFalse(c.IsPositive());
  Check(c.IsNegative());
  CheckFalse(c.IsNonNegative());
end;

procedure OLDoubleTest.PositiveNegativeDouble;
var
  d: OLDouble;
begin
  d := 5.0001;
  Check(d.IsPositive());
  CheckFalse(d.IsNegative());
  Check(d.IsNonNegative());

  d := 0;
  CheckFalse(d.IsPositive());
  CheckFalse(d.IsNegative());
  Check(d.IsNonNegative());

  d := -5.0001;
  CheckFalse(d.IsPositive());
  Check(d.IsNegative());
  CheckFalse(d.IsNonNegative());
end;

procedure OLIntegerTest.PositiveNegativeInteger;
var
  i: OLInteger;
begin
  i := 5;
  Check(i.IsPositive());
  CheckFalse(i.IsNegative());
  Check(i.IsNonNegative());

  i := 0;
  CheckFalse(i.IsPositive());
  CheckFalse(i.IsNegative());
  Check(i.IsNonNegative());

  i := -5;
  CheckFalse(i.IsPositive());
  Check(i.IsNegative());
  CheckFalse(i.IsNonNegative());
end;

procedure OLCurrencyTest.MathOperatorsCurrency;
var
  c, c2: OLCurrency;
begin
  c := 4 / 5;
  Check(c = 0.8);

  c := 4.5 / 2.25;
  Check(c = 2);

  c := 4.5 / 2;
  Check(c = 2.25);

  c := 1.10;

  c := c + 1.25;
  Check(c = 2.35);

  c := c - 4.20;
  Check(c = -1.85);

  c := c * -3;

  Check(c = 5.55);
  Check(c / 2 = 2.775);
  Check(c / 4 = 1.3875);
  Check(c / 1.11 = 5);

  c := -c;
  Check(c = -5.55);

  c := 4;
  Check(3 / c = 0.75);
  Check(8.88 / c = 2.22);

  c := Null;
  Check(c / 4 = Null);
  Check(c / 1.11 = Null);
  Check(3 / c = Null);
  Check(8.88 / c = Null);

  Check(c * 4 = Null);
  Check(8.88 * c = Null);


  Check(c2 / c = Null);
  Check(c2 * c = Null);
  c2 := 5.5;
  Check(c2 / c = Null);
  Check(c / c2 = Null);

  Check(c * c2 = Null);
  Check(c2 * c = Null);

  Check(c + 2.2 = Null);
  Check(3.3 + c = Null);

  Check(c - 2.2 = Null);
  Check(3.3 - c = Null);
end;

procedure OLDateTest.MathOperatorsDate;
var
  d, d2: OLDate;
begin
  d.SetToday();
  d2 := d;

  d := d + 1;
  d2 := d2.IncDay(1);
  Check(d = d2);

  d := d - 2;
  d2 := d2.IncDay(-2);
  Check(d = d2);
end;

procedure OLDateTimeTest.MathOperatorsDateTime;
var
  dt, dt2: OLDateTime;
begin
  dt.SetNow;
  dt2 := dt;

  dt := dt + 1;
  dt2 := dt2.IncDay(1);
  Check(dt = dt2);

  dt := dt - 2.5;
  dt2 := dt2.IncDay(-2).IncHour(-12);
  Check(dt = dt2);
end;

procedure OLDoubleTest.MathOperatorsDouble;
var
  d, d2: OLDouble;
  i: OLInteger;
begin
  d := i;

  d := 4 / 5;
  Check(d = 0.8);

  d := 4.5 / 2.25;
  Check(d = 2);

  d := 4.5 / 2;
  Check(d = 2.25);

  d := 1.10;

  d := d + 1.25;
  Check(d = 2.35);

  d := d - 4.20;
  Check(d = -1.85);

  d := d * -3;

  Check(d = 5.55);
  Check(d / 2 = 2.775);
  Check(d / 4 = 1.3875);
  Check(d / 1.11 = 5);

  d := -d;
  Check(d = -5.55);

  d := 4;
  Check(3 / d = 0.75);
  Check(8.88 / d = 2.22);

  d := Null;
  Check(d / 4 = Null);
  Check(d / 1.11 = Null);
  Check(3 / d = Null);
  Check(8.88 / d = Null);

  Check(d * 4 = Null);
  Check(8.88 * d = Null);


  Check(d2 / d = Null);
  Check(d2 * d = Null);
  d2 := 5.5;
  Check(d2 / d = Null);
  Check(d / d2 = Null);

  Check(d * d2 = Null);
  Check(d2 * d = Null);

  Check(d + 2.2 = Null);
  Check(3.3 + d = Null);

  Check(d - 2.2 = Null);
  Check(3.3 - d = Null);
end;

procedure OLIntegerTest.MathOperatorsInteger;
var
  i: OLInteger;
  d: OLDouble;
begin
  i := 1;

  i := i + 1;
  Check(i = 2);

  i := i - 4;
  Check(i = -2);

  i := i * -3;

  Check(i = 6);
  Check(i div 4 = 1);
  Check(i / 2 = 3);
  Check(i / 4 = 1.5);
  Check(i / 1.5 = 4);
  Check(i mod 4 = 2);

  Inc(i, 3);
  Check(i = 9);

  Inc(i);
  Check(i = 10);

  Dec(i);
  Check(i = 9);

  Dec(i, 2);
  Check(i = 7);

  i := -i;
  Check(i = -7);


  //When divident or divisor or both are null then all division results null
  //d is null
  Check(d / i = Null);
  Check(i / d = Null);
  Check(10 / d = Null);

  //both null
  i := Null;
  Check(d / i = Null);
  Check(i / d = Null);

  //i stays null
  d := 15.5;
  Check(d / i = Null);
  Check(10.1 / i = Null);
   Check(i / d = Null);
end;

procedure OLStringTest.MatchString;
var
  s: OLString;
begin
  s := 'Three';

  Check(s.MatchStr(['One', 'Two', 'Three']));
  CheckFalse(s.MatchStr(['one', 'two', 'three']));

  Check(s.MatchText(['one', 'two', 'three']));
end;

procedure OLStringTest.MathOperatorsString;
var
  s: OLString;
begin
  s := null;

  //When OLString is NULL, adding a string to it results NULL
  s := s + 'asd';
  Check(s.IsNull());

  s := 'asd';
  s := s + ' zxc';

  Check(s = 'asd zxc');
end;

procedure OLStringTest.MidStrString;
var
  s: OLString;
begin
  s := 'Three little mice.';
  Check(s.MidStr(2,3) = 'hre');
  Check(s.MidStr(7,6) = 'little');
end;

procedure OLCurrencyTest.MaxCurrency;
var
  c: OLCurrency;
begin
  c := 1.1234;
  Check(c.Max(0) = 1.1234);
  Check(c.Max(5.4321) = 5.4321);

  c := -5.4321;
  Check(c.Max(0) = 0);
  Check(c.Max(-6.1) = -5.4321);
  Check(c.Max(-4.201) = -4.201);
end;

procedure OLDoubleTest.MaxDouble;
var
  d: OLDouble;
begin
  d := 1.1234;
  Check(d.Max(0) = 1.1234);
  Check(d.Max(5.4321) = 5.4321);

  d := -5.4321;
  Check(d.Max(0) = 0);
  Check(d.Max(-6.1) = -5.4321);
  Check(d.Max(-4.201) = -4.201);
end;

procedure OLIntegerTest.MaxInteger;
var
  i: OLInteger;
begin
  i := 1;
  Check(i.Max(0) = 1);
  Check(i.Max(5) = 5);

  i := -5;
  Check(i.Max(0) = 0);
  Check(i.Max(-6) = -5);
  Check(i.Max(-4) = -4);
end;

procedure OLCurrencyTest.MinCurrency;
var
  c: OLCurrency;
begin
  c := 1.1234;
  Check(c.Min(0) = 0);
  Check(c.Min(5.4321) = 1.1234);

  c := -5.4321;
  Check(c.Min(0) = -5.4321);
  Check(c.Min(-6.1) = -6.1);
  Check(c.Min(-4.201) = -5.4321);
end;

procedure OLDoubleTest.MinDouble;
var
  d: OLDouble;
begin
  d := 1.1234;
  Check(d.Min(0) = 0);
  Check(d.Min(5.4321) = 1.1234);

  d := -5.4321;
  Check(d.Min(0) = -5.4321);
  Check(d.Min(-6.1) = -6.1);
  Check(d.Min(-4.201) = -5.4321);
end;

procedure OLIntegerTest.MinInteger;
var
  i: OLInteger;
begin
  i := 1;
  Check(i.Min(0) = 0);
  Check(i.Min(5) = 1);

  i := -5;
  Check(i.Min(0) = -5);
  Check(i.Min(-6) = -6);
  Check(i.Min(-4) = -5);
end;

procedure OLCurrencyTest.PowerCurrency;
var
  c: OLCurrency;
begin
  c := 5.1;
  Check(c.Sqr = 26.01);
  Check(c.Power(3) = 132.651);

  c := 0.5;
  Check(c.Power(0) = 1);
  Check(c.Power(-1) = 2);

  c := null;
  Check(c.Power(2) = null);
end;

procedure OLDoubleTest.PowerDouble;
var
  d: OLDouble;
begin
  d := 5.1;
  Check(d.Sqr = 26.01);
  Check(d.Power(3) = 132.651);

  d := 0.5;
  Check(d.Power(0) = 1);
  Check(d.Power(-1) = 2);

  d := 0.81;
  Check(d.Sqrt() = 0.9);
end;

procedure OLIntegerTest.PowerInteger;
var
  i: OLInteger;
begin
  i := 5;
  Check(i.Sqr = 25);
  Check(i.Power(3) = 125);

  i := 2;
  Check(i.Power(0) = 1);
  Check(i.Power(-1) = 0.5);
end;

procedure OLDateTest.RecodingDate;
var
  d: OLDate;
begin
  d := EncodeDate(2017,1,10);

  Check(d.RecodedYear(2016) = EncodeDate(2016,1,10));
  Check(d.RecodedMonth(8).RecodedDay(5) = EncodeDate(2017,8,5));
  Check(d.RecodedMonth(8) = EncodeDate(2017,8,10));
  Check(d.RecodedDay(23) = EncodeDate(2017,1,23));
end;

procedure OLDateTimeTest.RecodingDateTime;
var
  dt: OLDateTime;
begin
  dt := EncodeDateTime(2017,1,10,10,10,10,100);

  Check(dt.RecodedYear(2016) = EncodeDateTime(2016,1,10,10,10,10,100));
  Check(dt.RecodedMonth(8) = EncodeDateTime(2017,8,10,10,10,10,100));
  Check(dt.RecodedDay(23) = EncodeDateTime(2017,1,23,10,10,10,100));
  Check(dt.RecodedHour(16) = EncodeDateTime(2017,1,10,16,10,10,100));
  Check(dt.RecodedMinute(45) = EncodeDateTime(2017,1,10,10,45,10,100));
  Check(dt.RecodedSecond(15) = EncodeDateTime(2017,1,10,10,10,15,100));
  Check(dt.RecodedMilliSecond(123) = EncodeDateTime(2017,1,10,10,10,10,123));
end;

procedure OLCurrencyTest.RoundCurrency;
var
  c: OLCurrency;
begin
  c := 123.149;
  Check(c.Round(1) = 120);
  Check(c.Round(2) = 100);

  c := 155.155;
  Check(c.Round(1) = 160);
  Check(c.Round(2) = 200);

  c := 123.149;
  Check(c.Round(-1) = 123.1);
  Check(c.Round(-2) = 123.15);

  c := 155.155;
  Check(c.Round(-1) = 155.2);
  Check(c.Round(-2) = 155.16);
end;

procedure OLDoubleTest.RoundDouble;
var
  d: OLDouble;
begin
  d := 123.149;
  Check(d.Round(1) = 120);
  Check(d.Round(2) = 100);

  d := 155.155;
  Check(d.Round(1) = 160);
  Check(d.Round(2) = 200);

  d := 123.149;
  Check(d.Round(-1) = 123.1);
  Check(d.Round(-2) = 123.15);

  d := 155.155;
  Check(d.Round(-1) = 155.2);
  Check(d.Round(-2) = 155.16);

  d := 0.5;
  Check(d.Round() = 0);
  d := 1.5;
  Check(d.Round() = 2);
  d := 2.5;
  Check(d.Round() = 2);
  d := 3.5;
  Check(d.Round() = 4);

  d := -0.5;
  Check(d.Round() = 0);
  d := -1.5;
  Check(d.Round() = -2);
  d := -2.5;
  Check(d.Round() = -2);
end;

procedure OLIntegerTest.RoundInteger;
var
  i: OLInteger;
begin
  i := 123;
  Check(i.Round(1) = 120);
  Check(i.Round(2) = 100);

  i := 155;
  Check(i.Round(1) = 160);
  Check(i.Round(2) = 200);
end;

procedure OLDateTest.SameDayDate;
var
  d: OLDate;
  d2: OLDate;
begin
  d2 := EncodeDate(2017,1,10);

  d := EncodeDate(2017,1,10);
  Check(d.SameDay(d2));

  d := EncodeDate(2017,1,11);
  CheckFalse(d.SameDay(d2));
end;

procedure OLDateTimeTest.SameDayDateTime;
var
  dt: OLDateTime;
  dtt: OLDateTime;
begin
  dtt := EncodeDateTime(2017,1,10,10,10,10,100);

  dt := EncodeDateTime(2017,1,10,15,10,10,100);
  Check(dt.SameDay(dtt));

  dt := EncodeDateTime(2017,1,11,10,10,10,100);
  CheckFalse(dt.SameDay(dtt));
end;


procedure OLDateTimeTest.SameTimeDateTime;
var
  dt: OLDateTime;
  dt2: OLDateTime;
begin
  dt2 := EncodeDateTime(2017,1,10,10,10,10,100);

  dt := EncodeDateTime(2017,1,15,10,10,10,100);
  Check(dt.SameTime(dt2));

  dt := EncodeDateTime(2017,1,10,14,10,10,100);
  CheckFalse(dt.SameTime(dt2));
end;

procedure OLDoubleTest.SameValueDouble;
var
  d: OLDouble;
begin
  d := 4.01;
  Check(d.SameValue(4.01));
  CheckFalse(d.SameValue(4.011));
  Check(d.SameValue(4.011, 0.01));
end;

procedure OLBooleanTest.SetBoolean;
var
  b: OLBoolean;
begin
  b := False;
  CheckFalse(b);

  b := True;
  CheckTrue(b);

  b := 'true';
  CheckTrue(b);

  b := 'false';
  CheckFalse(b);

  b := 1;
  CheckTrue(b);

  b := 0;
  CheckFalse(b);
end;

procedure OLDateTest.SpanDate;
var
  d, d2: OLDate;
begin
  d.EncodeDate(2000, 1,2);
  d2 := d.RecodedYear(2004).RecodedMonth(7);

  Check(d2.DaysBetween(d) = DateUtils.DaysBetween(d2, d));
  Check(d2.WeeksBetween(d) = DateUtils.WeeksBetween(d2, d));
  Check(d2.MonthsBetween(d) = 54); //DateUtils.MonthsBetween(d2, d) returns aproximate number of months
  Check(d2.YearsBetween(d) = DateUtils.YearsBetween(d2, d));


  Check(d2.YearSpan(d) = DateUtils.YearSpan(d2, d));
  Check(d2.MonthSpan(d) = DateUtils.MonthSpan(d2, d));
  Check(d2.WeekSpan(d) = DateUtils.WeekSpan(d2, d));
end;

procedure OLDateTimeTest.SpanDateTime;
var
  dt, dt2: OLDateTime;
begin
  dt.EncodeDateTime(2000, 1,2,3,45,25,400);
  dt2 := dt.RecodedYear(2004).RecodedMonth(7);

  Check(dt2.MilliSecondsBetween(dt) = DateUtils.MilliSecondsBetween(dt2, dt));
  Check(dt2.SecondsBetween(dt) = DateUtils.SecondsBetween(dt2, dt));
  Check(dt2.MinutesBetween(dt) = DateUtils.MinutesBetween(dt2, dt));
  Check(dt2.HoursBetween(dt) = DateUtils.HoursBetween(dt2, dt));
  Check(dt2.DaysBetween(dt) = DateUtils.DaysBetween(dt2, dt));
  Check(dt2.WeeksBetween(dt) = DateUtils.WeeksBetween(dt2, dt));
  Check(dt2.MonthsBetween(dt) = 54); //DateUtils.MonthsBetween(d2, d) returns aproximate number of months
  Check(dt2.YearsBetween(dt) = DateUtils.YearsBetween(dt2, dt));


  Check(dt2.YearSpan(dt) = DateUtils.YearSpan(dt2, dt));
  Check(dt2.MonthSpan(dt) = DateUtils.MonthSpan(dt2, dt));
  Check(dt2.WeekSpan(dt) = DateUtils.WeekSpan(dt2, dt));
  Check(dt2.DaySpan(dt) = DateUtils.DaySpan(dt2, dt));
  Check(dt2.HourSpan(dt) = DateUtils.HourSpan(dt2, dt));
  Check(dt2.MinuteSpan(dt) = DateUtils.MinuteSpan(dt2, dt));
  Check(dt2.SecondSpan(dt) = DateUtils.SecondSpan(dt2, dt));
  Check(dt2.MilliSecondSpan(dt) = DateUtils.MilliSecondSpan(dt2, dt));
end;

procedure OLDateTest.StartOfEndOfDate;
var
  dt: TDate;
  d: OLDate;
begin
  dt := EncodeDate(2017,1,10);
  d := dt;

  Check(d.StartOfTheYear() = StartOfTheYear(dt));
  Check(d.EndOfTheYear() = EndOfTheYear(dt));

  Check(d.StartOfTheMonth() = StartOfTheMonth(dt));
  Check(d.EndOfTheMonth() = EndOfTheMonth(dt));

  Check(d.StartOfTheWeek() = StartOfTheWeek(dt));
  Check(d.EndOfTheWeek() = EndOfTheWeek(dt));
end;

procedure OLDateTimeTest.StartOfEndOfDateTime;
var
  dtt: TDateTime;
  dt: OLDateTime;
begin
  dtt := EncodeDateTime(2017,1,10,9,38,15,100);
  dt := dtt;

  Check(dt.StartOfTheYear() = StartOfTheYear(dtt));
  Check(dt.EndOfTheYear() = EndOfTheYear(dtt));

  Check(dt.StartOfTheMonth() = StartOfTheMonth(dtt));
  Check(dt.EndOfTheMonth() = EndOfTheMonth(dtt));

  Check(dt.StartOfTheWeek() = StartOfTheWeek(dtt));
  Check(dt.EndOfTheWeek() = EndOfTheWeek(dtt));

  Check(dt.StartOfTheDay() = StartOfTheDay(dtt));
  Check(dt.EndOfTheDay() = EndOfTheDay(dtt));
end;

procedure OLDateTimeTest.TimeOfDateTime;
var
  dt: OLDateTime;
begin
  dt := EncodeDateTime(2017,1,10,10,10,10,100);

  Check(dt.TimeOf() = EncodeTime(10,10,10,100));
end;

procedure OLBooleanTest.ToStringBoolean;
var
  b: OLBoolean;
begin
  b := True;
  CheckEqualsString('True', b.ToString());

  b := False;
  CheckEqualsString('False', b.ToString());
end;

procedure OLBooleanTest.XorBoolean;
var
  b: OLBoolean;
begin
  b := True;
  CheckTrue(b xor False);
  CheckFalse(b xor True);

  b := False;
  CheckTrue(b xor True);
  CheckFalse(b xor False);
end;

procedure OLDateTest.YesterdayDate;
var
  d: OLDate;
begin
  d.SetYesterday();
  Check(d = Yesterday());

  Check(OLDate.Yesterday() = Yesterday());
end;

procedure OLDateTimeTest.YesterdayDateTime;
var
  dt: OLDateTime;
begin
  dt.SetYesterday();
  Check(dt = Yesterday());

  Check(OLDateTime.Yesterday = Yesterday());
end;

procedure OLIntegerTest.EqualsInteger;
var
  i: OLInteger;
begin
  CheckTrue(i = Null);

  i := 3;

  CheckFalse(i = Null);

  CheckTrue(i = 3);
  CheckFalse(i = 1);
  CheckFalse(i = 1);
  CheckFalse(i = 0);
end;

function OLStringTest.GetTemp: String;
var
  PathLocal : array[0..MAX_PATH] of Char;
begin
  Result := '';
  if GetTempPath(Length(PathLocal), PathLocal)>0 then
  begin
    Result := PathLocal;
  end;
end;

procedure OLStringTest.Base64String;
var
  sl, sl2: TStringList;
  TempFileName, TempFileName2: string;

  s: OLString;
begin
  TempFileName := GetTemp() + 'test.txt';
  TempFileName2 := GetTemp() + 'test2.txt';

  sl := TStringList.Create;
  try
    sl.Add('Test1');
    sl.Add('Test2');

    sl.SaveToFile(TempFileName);

    s.EndcodeBase64FromFile(TempFileName);
    Check(s = 'VGVzdDENClRlc3QyDQo=');

    s.DecodeBase64ToFile(TempFileName2);

    sl2 := TStringList.Create;
    try
      sl2.LoadFromFile(TempFileName2);

      Check(sl.Text = sl2.Text);

    finally
      sl2.Free();
    end;
  finally
    sl.Free();
  end;

  DeleteFile(TempFileName);
  DeleteFile(TempFileName2);
end;

procedure OLStringTest.CompressionString;
var
  s, s2: OLString;
const
  BondText = 'My name is Bond. My name is Bond. My name is Bond. My name is Bond.';
begin
  s := BondText;

  s := s.Compressed();

  s2 := s;

  s2 := s2.Decompressed;

  Check(s2 = BondText);
end;

procedure OLStringTest.ContainsString;
var
  s: OLString;
begin
  s := 'My name is Bond. James Bond.';

  //Case sensitive
  Check(s.ContainsStr('Bond'));
  CheckFalse(s.ContainsStr('bond'));

  //Case insensitive
  Check(s.ContainsText('bond'));
end;

procedure OLStringTest.CSVFieldValueString;
var
  s: OLString;
begin
  s :='First Name;Last Name;City';
  Check(s.CSVFieldCount() = 3);
  Check(s.CSVFieldValue(0) = 'First Name');
  Check(s.CSVFieldValue(1) = 'Last Name');
  Check(s.CSVFieldValue(2) = 'City');

  s.SetCSVFieldValue(2,'Town');
  Check(s.CSVFieldValue(2) = 'Town');
  Check(s.CSV[2] = 'Town');

  s.CSV[3] := 'Email address';
  Check(s.CSVFieldValue(3) = 'Email address');


  s :='First Name|Last Name|City|Date';
  Check(s.CSVFieldCount('|') = 4);
  Check(s.CSVFieldValue(0, '|') = 'First Name');
  Check(s.CSVFieldValue(1, '|') = 'Last Name');
  Check(s.CSVFieldValue(2, '|') = 'City');
  Check(s.CSVFieldValue(3, '|') = 'Date');

  s.SetCSVFieldValue(5, 'Email address', '|');
  Check(s.CSVFieldValue(4, '|') = '');
  Check(s.CSVFieldValue(5, '|') = 'Email address');
end;

procedure OLStringTest.DigitsOnlyNoSpacesString;
var
  s: OLString;
begin
  s := 'One 23456';

  Check(s.SpacesRemoved() = 'One23456');
  Check(s.DigitsOnly() = '23456');
end;

procedure OLStringTest.DupeString;
var
  s: OLString;
begin
  s := 'One ';

  Check(s.RepeatedString(5) = 'One One One One One ');
end;

procedure OLStringTest.EqualsString;
var
  s: OLString;
  str: string;
begin
  CheckFalse(s = Null);

  Check(s = '');
  Check(s.IsEmptyStr());

  s := Null;

  CheckTrue(s = Null);

  s := '';

  CheckFalse(s = Null);

  s := 'asd';
  str := 'asd';

  CheckTrue(s = str);
  CheckFalse(s = 'zxc');

  s := Null;
  CheckTrue(s = Null);
end;

procedure OLStringTest.FilePathExtract;
var
  s: OLString;
begin
  s := 'c:\temp\test.txt';
  Check(s.ExtractedFileDriveString() = 'c:');
  Check(s.ExtractedFileDir() = 'c:\temp');
  Check(s.ExtractedFilePath() = 'c:\temp\');
  Check(s.ExtractedFileName() = 'test.txt');
  Check(s.ExtractedFileExt() = '.txt');
end;

procedure OLStringTest.FindPatternString;
var
  s: OLString;
  pat: TStringPatternFind;
begin
  s := 'My name is Bond. My name is James Bond.';

  Check(s.FindPatternStr('name is ', '.') = 'Bond');
  Check(s.FindPatternStr('name is ', '.', 15) = 'James Bond');
  Check(s.FindPatternStr('NAME IS ', '.', 15, csCaseInsensitive) = 'James Bond');

  pat := s.FindPattern('NAME IS ', '.', 1, csCaseInsensitive);
  Check(pat.Value = 'Bond');
  Check(pat.Position = 12);

  s := '<head><title>JB Web Page</title></head>';
  Check(s.FindPatternStr('TITLE') = 'JB Web Page'); //ignoring case as default
  Check(s.FindPatternStr('title', 5, csCaseSensitive) = 'JB Web Page');
  CheckFalse(s.FindPatternStr('TITLE', 5, csCaseSensitive) <> '');

  pat := s.FindPattern('TITLE');
  Check(pat.Value = 'JB Web Page');
  Check(pat.Position = 14);
end;

procedure OLStringTest.FormatString;
var
  s: OLString;
begin
  s := 'My name is %s and I am %d years old.';
  s := s.Formated(['Agnieszka', 18]);
  Check(s = 'My name is Agnieszka and I am 18 years old.');
end;

procedure OLDoubleTest.FloorDouble;
var
  d: OLDouble;
begin
  d := 123.149;
  Check(d.Floor() = 123);

  d := -123.149;
  Check(d.Floor() = -124);
end;

procedure OLIntegerTest.ForLoopInteger;
var
  i: OLInteger;
  i2: integer;
begin
  i2 := 0;
  i.ForLoop(1, 10, procedure
  begin
    Inc(i2);
  end);

  Check((i2 = 10) and (i = 10));

  i2 := 0;
  i.ForLoop(5, -5, procedure
  begin
    i2 := i2 + i;
  end);

  Check((i2 = 0) and (i = -5));
end;

procedure OLIntegerTest.GreaterInteger;
var
  i: OLInteger;
begin
  i := 3;

  CheckFalse(i > Null);

  CheckTrue(i > 2.1);
  CheckFalse(i > 3);
  CheckFalse(i > 4);
end;

procedure OLStringTest.GreaterString;
var
  s: OLString;
  str: string;
begin
  CheckFalse(s > Null);

  str := 'aaa';
  s := 'bbb';

  CheckFalse(s > Null);

  CheckTrue(s > str);
  CheckFalse(s > s);
end;

procedure OLStringTest.HashString;
var
  s: OLString;
begin
  s := 'p@ssword753';

  Check(s.Hash() = 732684085);
  Check(s.HashStr() = '2BABDF35');

  Check(s.Hash('s@It') = 3549827675);
  Check(s.HashStr('s@It') = 'D396125B');
end;

procedure OLIntegerTest.GreaterEqualInteger;
var
  i: OLInteger;
begin
  CheckTrue(i >= Null);

  i := 3;

  CheckFalse(i >= Null);

  CheckTrue(i >= 2.1);
  CheckTrue(i >= 3);

  i := -3;
  CheckFalse(i >= -2);
end;

function OLStringTest.ConnectedToInternet : boolean;
var
  origin : cardinal;
begin
   result := InternetGetConnectedState(@origin, 0);
end;

procedure OLStringTest.GetFromURLString;
var
  s: OLString;
begin
  if ConnectedToInternet() then
  begin
    s.GetFromUrl('https://www.google.com');
    Check(s.FindPatternStr('title').ContainsText('google'));
  end
  else
    Fail('Cannot be testet without Internet connection.');
end;

procedure OLStringTest.GetLineStartPositionString;
var
  s: OLString;
begin
  s :='';
  s.LineAdd('12345');
  s.LineAdd('890123');

  Check(s.GetLineStartPosition(0) = 1);
  Check(s.GetLineStartPosition(1) = 8);
end;

procedure OLStringTest.GreaterEqualString;
var
  s: OLString;
  str, str2: string;
begin
  s := Null;

  Check(s >= Null);

  str := 'aaa';
  s := 'aab';
  str2 := 'aac';

  CheckFalse(s >= Null);

  CheckTrue(s >= str);
  CheckTrue(s >= s);
  CheckFalse(s >= str2);
end;

procedure OLIntegerTest.LessInteger;
var
  i: OLInteger;
begin
  i := 3;

  CheckFalse(i < 3);
  CheckTrue(i < 3.1);
end;

procedure OLStringTest.LessString;
var
  s: OLString;
  str: string;
begin
  CheckFalse(s > Null);

  s := 'asd';
  CheckFalse(s > Null);

  s := '���';
  str := 'DDD';
  CheckFalse(s < str); //'���' is greater then 'D' (!)

  s := 'CCC';
  str := 'DDD';
  Check(s < str);

  CheckFalse(s < s);
end;

procedure OLStringTest.LinesString;
var
  s, s2: OLString;
  TestFileName: string;
begin
  Check(s.LineCount = 1); //Empty string

  s.LineAdd('First line');
  s.LineAdd('Some line');
  Check(s.LineCount = 2);

  Check(s.Lines[1] = 'Some line');

  s.LineInsertAt(1, 'Second line');

  Check(s.Lines[0] = 'First line');
  Check(s.Lines[1] = 'Second line');
  Check(s.Lines[2] = 'Some line');

  s.Lines[2] := 'Third line';

  Check(s.Lines[2] = 'Third line');

  Check(s.LineIndexOf('Second line') = 1);

  s.LineDelete(1);
  Check(s.LineIndexOf('Second line').IsNull());


  TestFileName := GetTemp() + 'test.txt';
  s.SaveToFile(TestFileName);

  s := '';

  s.LoadFromFile(TestFileName);
  DeleteFile(TestFileName); //Clean up

  Check(s.Lines[1] = 'Third line');

  s := '';
  s.LineAdd('');
  s.LineAdd('Second line');
  Check(s.Lines[1] = 'Second line');

  s := '';
  s.LineAdd('');
  s.LineAdd('');
  Check(s.Lines[0] = '');
  Check(s.Lines[1] = '');

  s.LineAdd('Third line');
  Check(s.Lines[1] = '');
  Check(s.Lines[2] = 'Third line');

  s2 := s.LineAdded('Fourth line')
         .LineAdded('Fifth line')
         .LineAdded('Sixth line');
  Check(s2.Lines[5] = 'Sixth line');

  s2.LineDelete(2);
  Check(s2.Lines[2] = 'Fourth line');

  s2.LineInsertAt(2, 'New third line');
  Check(s2.Lines[2] = 'New third line');
  Check(s2.Lines[3] = 'Fourth line');

  s := Null;
  Check(s.LineCount.IsNull());
end;

procedure OLStringTest.LowerUpperCaseString;
var
  s: OLString;
begin
  s := 'James Bond';

  Check(s.UpperCase() = 'JAMES BOND');
  Check(s.LowerCase() = 'james bond');

  s := 'james bond';
  Check(s.InitCaps() = 'James Bond');

  s := 'jAMES boND';
  Check(s.InitCaps() = 'James Bond');
end;

procedure OLIntegerTest.LessEqualInteger;
var
  i: OLInteger;
begin
  CheckTrue(i >= Null);

  i := 3;

  CheckFalse(i <= 2.5);
  CheckTrue(i <= 3);

  i := -2;
  CheckTrue(i <= -2);
end;

procedure OLStringTest.LastDelimiterString;
var
  s: OLString;
begin
  s := '123_567_90';
  Check(s.LastDelimiterPosition('_') = 8);
end;

procedure OLStringTest.LeadTrailAddString;
var
  s: OLString;
begin
  s := '1234';
  Check(s.LeadingCharsAdded('-', 7) = '---1234');
  Check(s.LeadingSpacesAdded(8) = '    1234');
  Check(s.LeadingZerosAdded(6) = '001234');

  Check(s.TrailingCharsAdded('-', 7) = '1234---');
  Check(s.TrailingSpacesAdded(8) = '1234    ');
end;

procedure OLStringTest.LeftRightString;
var
  s: OLString;
begin
  s := '1234KaBoom';
  Check(s.LeftStr(3) = '123');
  Check(s.RightStr(4) = 'Boom');
  Check(s.RightStrFrom(5) = 'KaBoom');
  Check(s.EndingRemoved(5) = '1234K');
end;

procedure OLStringTest.LengthString;
var
  s: OLString;
begin
  CheckFalse(s.Length().IsNull());

  s := Null;
  Check(s.Length().IsNull());

  s := '';
  Check(s.Length() = 0);

  s := 'Agnieszka';
  Check(s.Length = 9);
end;

procedure OLStringTest.LessEqualString;
var
  s: OLString;
  str, str2: string;
begin
  CheckFalse(s <= Null);

  s := Null;

  Check(s <= Null);

  str := 'ZZa';
  s := 'ZZx';
  str2 := 'ZZz';

  CheckFalse(s <= Null);

  CheckTrue(s <= str2);
  CheckTrue(s <= s);
  CheckFalse(s <= str);
end;

procedure OLIntegerTest.NotEqualInteger;
var
  i: OLInteger;
begin
  CheckFalse(i <> Null);

  i := 3;

  CheckTrue(i <> Null);

  CheckTrue(i <> -1.1);
  CheckFalse(i <> 3);
end;

procedure OLStringTest.NotEqualString;
var
  s: OLString;
  str: string;
begin
  Check(s <> Null);

  s := Null;

  CheckFalse(s <> Null);

  s := 'ZZZZZ';
  str := 'AAAA';

  CheckTrue(s <> Null);

  CheckTrue(s <> str);
  CheckFalse(s <> s);
end;

procedure OLStringTest.OccurrancesString;
var
  s: OLString;
begin
  s := 'My name is Bond. My name is Bond. My name is Bond. My name is Bond.';

  Check(s.OccurrencesCount('Bond') = 4);
  Check(s.OccurrencesCount('bond') = 0);
  Check(s.OccurrencesCount('bond', csCaseInsensitive) = 4);

  Check(s.OccurrencesPosition('Bond', 0) = 12);
  Check(s.OccurrencesPosition('Bond', 1) = 29);
  Check(s.OccurrencesPosition('Bond', 2) = 46);
  Check(s.OccurrencesPosition('Bond', 3) = 63);


  Check(s.OccurrencesPosition('bond', 3, csCaseInsensitive) = 63);
end;

procedure OLStringTest.PositionString;
var
  s: OLString;
  i: OLInteger;
begin
  s := 'My name is Bond. My name is James Bond.';

  i := s.Pos('Bond');
  Check(i = 12);

  i := s.PosEx('Bond', i + 1);
  Check(i = 35);

  i := s.Pos('bond', csCaseInsensitive);
  Check(i = 12);

  i := s.PosEx('bond', i + 1, csCaseInsensitive);
  Check(i = 35);
end;

procedure OLStringTest.QuotedString;
var
  s: OLString;
begin
  s := 'Quo Vadis';
  Check(s.QuotedStr() = QuotedStr(s));
end;

procedure OLStringTest.ReplaceString;
var
  s: OLString;
begin
  s := 'My name is Bond. My name is James Bond.';
  s := s.Replaced('Bond', 'Bean');
  Check(s = 'My name is Bean. My name is James Bean.');

  s := 'My name is Bond. My name is James Bond.';
  s := s.ReplacedFirst('Bond', 'Bean');
  Check(s = 'My name is Bean. My name is James Bond.');

  s := 'My name is Bond. My name is James Bond.';
  s := s.ReplacedText('bond', 'Bean');
  Check(s = 'My name is Bean. My name is James Bean.');

  s := 'My name is Bond. My name is James Bond.';
  s := s.ReplacedFirstText('BOND', 'Bean');
  Check(s = 'My name is Bean. My name is James Bond.');

  s := 'My name is Bond. My name is James Bond.';
  s := s.Replaced('Bond', 'Bean').Replaced('James', 'Johnny');
  Check(s = 'My name is Bean. My name is Johnny Bean.');
end;

procedure OLStringTest.ReverseString;
var
  s: OLString;
begin
  s := 'EVA';

  Check(s.ReversedString() = 'AVE');
end;

procedure OLDateTimeTest.NowDateTime;
var
  dt: OLDateTime;
begin
  dt.SetNow();

  Check(dt = Now());
end;

procedure OLIntegerTest.SetInteger;
var
  i: OLInteger;
begin
  i := 1;
  Check(i = 1);

  i := 0;
  Check(i = 0);

  i := '-100';
  Check(i = -100);
end;

procedure OLIntegerTest.SetRandomPrimeInteger;
var
  i: OLInteger;
begin
  i.SetRandomPrime(1000, 100000);
  Check(i.IsPrime() and (i >= 1000) and (i <= 100000), i.ToString());

  i.SetRandomPrime(5000);
  Check(i.IsPrime() and (i <= 5000), i.ToString());
end;

procedure OLStringTest.SameString;
var
  s: OLString;
begin
  s := 'Quo Vadis';

  Check(s.SameStr('Quo ' + 'Vadis'));
  CheckFalse(s.SameStr('quo vadis'));
  Check(s.SameText('quo vadis'));
end;

procedure OLStringTest.SetString;
var
  s: OLString;
  str: string;
begin
  str := 'Hanna';

  s := str;
  Check(s = str);

  //Change a char in a string using index
  s[1] := 'P'; // Hanna -> Panna
  Check(s = 'Panna');

  str := 'Kasia';
  s := str;
  Check(s = str);
  CheckFalse(s = 'kasia');

  // assigning TDate to OLString - automatic conversion to string
  s := EncodeDate(2017,5,8);
  str := DateToStr(EncodeDate(2017,5,8));
  Check(s = str);

  // assigning float number to OLString - automatic conversion to string
  s := 47123.5;
  Check(s = FloatToStr(47123.5));
end;

procedure OLStringTest.SmartToDateString;
var
  s : OLString;

begin
  s := ssTD;
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today());

  s := 'td';
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today());

  s := 't';
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today());

  s := 'y';
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Yesterday());

  s := 'yd';
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Yesterday());

  s := 'tm';
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Tomorrow());

  s := 'sy'; // Beginning of the year
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().StartOfTheYear());

  s := 'ey'; // End of the year
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().EndOfTheYear());

  s := 'sm';  // Beginning of the month
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().StartOfTheMonth());

  s := 'em'; // End of the month
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().EndOfTheMonth());

  s := 'sny'; // Beginning of the next year
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().IncYear().StartOfTheYear());

  s := 'eny'; // End of the next year
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().IncYear().EndOfTheYear());

  s := 'snm'; // Beginning of the next month
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().IncMonth().StartOfTheMonth());

  s := 'enm'; // End of the next month
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().IncMonth().EndOfTheMonth());

  s := 'spy'; // Beginning of the prior year
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().IncYear(-1).StartOfTheYear());

  s := 'epy'; // End of the prior year
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().IncYear(-1).EndOfTheYear());

  s := 'spm'; // Beginning of the prior month
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().IncMonth(-1).StartOfTheMonth());

  s := 'epm'; // End of the prior month
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().IncMonth(-1).EndOfTheMonth());

  s := '5'; // Day
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().RecodedDay(5));

  s := '26'; // Day
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().RecodedDay(26));

  s := '426'; // Month + Day
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().RecodedMonth(4).RecodedDay(26));

  s := '1126'; // Month + Day
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().RecodedMonth(11).RecodedDay(26));

  s := '81126'; // Year + Month + Day
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().RecodedYear(2008).RecodedMonth(11).RecodedDay(26));

  s := '80106'; // Year + Month + Day
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().RecodedYear(2008).RecodedMonth(1).RecodedDay(6));

  s := '161126'; // Year + Month + Day
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().RecodedYear(2016).RecodedMonth(11).RecodedDay(26));

  s := '20151126'; // Full Year + Month + Day
  Check(s.TrySmartStrToDate());
  Check(s.SmartStrToDate() = OLDate.Today().RecodedYear(2015).RecodedMonth(11).RecodedDay(26));
end;

procedure OLStringTest.SplitString;
var
  s: OLString;
  lst: TStringDynArray;
begin
  s := 'One;Two;Three;Four';
  lst := s.SplitString();

  Check(lst[0] = 'One');
  Check(lst[1] = 'Two');
  Check(lst[2] = 'Three');
  Check(lst[3] = 'Four');

  s := 'Four,Three,Two,One';
  lst := s.SplitString(',');

  Check(lst[0] = 'Four');
  Check(lst[2] = 'Two');
  Check(lst[1] = 'Three');
  Check(lst[3] = 'One');
end;

procedure OLStringTest.StartsEndsString;
var
  s: OLString;
begin
  s := 'One Two Three Four';

  Check(s.StartsStr('One'));
  CheckFalse(s.StartsStr('one'));
  Check(s.StartsText('ONE'));

  Check(s.EndsStr('Four'));
  CheckFalse(s.EndsStr('four'));
  Check(s.EndsText('four'));
end;

procedure OLDateTest.TodayDate;
var
  d: OLDate;
begin
  d.SetToday();
  Check(d = Today());

  Check(OLDate.Today = Today());
end;

procedure OLDateTimeTest.TodayDateTime;
var
  dt: OLDateTime;
begin
  dt.SetToday();
  Check(dt = Today());

  Check(OLDateTime.Today = Today());
end;

procedure OLDateTest.TomorrowDate;
var
  d: OLDate;
begin
  d.SetTomorow();
  Check(d = Tomorrow());

  Check(OLDate.Tomorrow = Tomorrow());
end;

procedure OLDateTimeTest.TomorrowDateTime;
var
  dt: OLDateTime;
begin
  dt.SetTomorrow();
  Check(dt = Tomorrow());

  Check(OLDateTime.Tomorrow = Tomorrow());
end;

procedure OLIntegerTest.IsNullInteger;
var
  i: OLInteger;
begin
  Check(i.IsNull());

  i := 1;
  Check(i.IsNull() = False);

  i := Null;
  Check(i.IsNull());
end;

procedure OLStringTest.IBANString;
var
  s: OLString;
begin
  s := 'PL86101014690004882221000000';
  Check(s.IsValidIBAN());

  //Country code is obligatory
  s := '86101014690004882221000000';
  CheckFalse(s.IsValidIBAN());

  //IBAN number can contain spaces. They are removed prior the validation
  s := 'PL 86 1010 1469 0004 8822 2100 0000';
  Check(s.IsValidIBAN());

  s := 'PL 86 1010 1469 0004 8822 2100 0001';
  CheckFalse(s.IsValidIBAN());
end;

procedure OLStringTest.IncludeExcludeFinalCharString;
var
  s: OLString;
begin
  s := 'c:\temp\';
  Check(s.TrailingPathDelimiterExcluded() = 'c:\temp');
  s := 'c:\temp';
  Check(s.TrailingPathDelimiterExcluded() = 'c:\temp');

  s := 'c:\asd';
  Check(s.TrailingPathDelimiterIncluded() = 'c:\asd\');
  s := 'c:\asd\';
  Check(s.TrailingPathDelimiterIncluded() = 'c:\asd\');

  s := '1;2;3;';
  Check(s.TrailingCharExcluded(';') = '1;2;3');
  s := '1;2;3';
  Check(s.TrailingCharExcluded(';') = '1;2;3');

  s := '4|5|6';
  Check(s.TrailingCharIncluded('|') = '4|5|6|');
  s := '4|5|6|';
  Check(s.TrailingCharIncluded('|') = '4|5|6|');

  s := '7,8,9';
  Check(s.TrailingComaIncluded() = '7,8,9,');
  s := '7,8,9,';
  Check(s.TrailingComaIncluded() = '7,8,9,');

  s := '7,8,9';
  Check(s.TrailingComaExcluded() = '7,8,9');
  s := '7,8,9,';
  Check(s.TrailingComaExcluded() = '7,8,9');
end;

procedure OLStringTest.IndexString;
var
  s: OLString;
begin
  s := 'Three';

  Check(s.IndexStr(['One', 'Two', 'Three']) = 2);
  Check(s.IndexStr(['one', 'two', 'three']).IsNull());

  Check(s.IndexText(['one', 'two', 'three']) = 2);
end;

procedure OLStringTest.InsertDeleteString;
var
  s: OLString;
begin
  s := 'My name is Bond. Bond.';

  s := s.Inserted('James ', 18);
  Check(s = 'My name is Bond. James Bond.');

  s := s.Deleted(17, 12);
  Check(s = 'My name is Bond.');

  s := s.Inserted('Hello. ', 1);
  Check(s = 'Hello. My name is Bond.');

  s := '123456789';
  s := s.Deleted(4,3);
  Check(s = '123789');
end;

procedure OLStringTest.IsNullString;
var
  s: OLString;
begin
  CheckFalse(s.IsNull());

  s := 'Agnieszka';
  CheckFalse(s.IsNull());

  s := Null;
  Check(s.IsNull());
end;

procedure OLDateTest.IsTodayDate;
var
  d: OLDate;
begin
  d := Now();
  Check(d.IsToday());

  d := Tomorrow();
  CheckFalse(d.IsToday());
end;

procedure OLDateTimeTest.IsTodayDateTime;
var
  dt: OLDateTime;
begin
  dt := Now();
  Check(dt.IsToday());

  dt := Tomorrow();
  CheckFalse(dt.IsToday());
end;

procedure OLDoubleTest.IsZeroDouble;
var
  d: OLDouble;
begin
  d := 0;
  Check(d.IsZero());
  d := 0.09999;
  Check(d.IsZero(0.1));
  CheckFalse(d.IsZero());
end;

procedure OLIntegerTest.ToStringInteger;
var
  i: OLInteger;
begin
  i := 123;
  CheckEqualsString('123', i.ToString());

  i := -100123;
  CheckEqualsString('-100123', i.ToString());
end;


procedure OLStringTest.ConvertString;
var
  s: OLString;

  dt: TDateTime;
  c: Currency;
  d: Double;
  i: Integer;
  i64: Int64;
  dt2: TDateTime;
  dat: TDate;

  olc: OLCurrency;
  old: OLDouble;
  oli: OLInteger;
  oldt2: OLDateTime;
  oldat: OLDate;
begin
  s := CurrToStr(2.55);
  Check(s.TryToCurr());
  Check(s.ToCurr() = 2.55);
  Check(s.TryToCurr(c));
  Check(c = 2.55);
  Check(s.TryToCurr(olc));
  Check(olc = 2.55);

  s := FloatToStr(2.55);
  Check(s.TryToFloat());
  Check(s.ToFloat() = 2.55);
  Check(s.TryToFloat(d));
  Check(abs(d - 2.55) < 1e-5);
  Check(s.TryToFloat(old));
  Check(old = 2.55);

  s := '255';
  Check(s.TryToInt());
  Check(s.ToInt() = 255);
  Check(s.TryToInt(i));
  Check(i = 255);
  Check(s.TryToInt(oli));
  Check(oli = 255);

  s := '255000000000000000';
  Check(s.TryToInt64());
  Check(s.ToInt64 = 255000000000000000);
  Check(s.TryToInt64(i64));
  Check(i64 = 255000000000000000);

  dt := Now;
  dt := RecodeMilliSecond(now, 0); //No milliseconds in string
  s := DateTimeToStr(dt);
  Check(s.TryToDateTime());
  Check(s.ToDateTime() = dt);
  Check(s.TryToDateTime(dt2));
  Check(dt2 = dt);
  Check(s.TryToDateTime(oldt2));
  Check(oldt2 = dt);

  dat := Date();
  s := DateToStr(dat);
  Check(s.TryToDate());
  Check(s.ToDate() = dat);
  Check(s.TryToDate(dt2));
  Check(dt2 = dat);
  Check(s.TryToDate(oldat));
  Check(oldat = dat);
end;

procedure OLStringTest.ToStringString;
var
  s: OLString;
begin
  Check(s.ToString() = '');

  s := 'Agnieszka';
  Check(s = s.ToString());
end;

procedure OLStringTest.TrimmedString;
var
  s: OLString;
begin
  s := ' BOND ';
  Check(s.Trimmed() = 'BOND');
  Check(s.TrimmedLeft() = 'BOND ');
  Check(s.TrimmedRight() = ' BOND');
end;

procedure OLDateTest.WeeksInYearDate;
var
  d: OLDate;
  dt: TDate;
  i: integer;
begin
  for i := 2000 to 2020 do
  begin
    dt := EncodeDate(i,1,10);
    d := dt;
    Check(d.WeeksInYear = WeeksInYear(dt));
  end;
end;

procedure OLDateTimeTest.WeeksInYearDateTime;
var
  dt: OLDateTime;
  dtt: TDateTime;
  i: integer;
begin
  for i := 2000 to 2020 do
  begin
    dtt := EncodeDateTime(i,1,10,10,10,10,100);
    dt := dtt;
    Check(dt.WeeksInYear = WeeksInYear(dtt));
  end;
end;

procedure OLCurrencyTest.EqualsCurrency;
var
  c: OLCurrency;
begin
  CheckTrue(c = Null);

  c := 3.52;

  CheckFalse(c = Null);

  CheckTrue(c = 3.52);
  CheckFalse(c = 1.1);
  CheckFalse(c = -1.2);
  CheckFalse(c = 0);
  CheckFalse(c = 3.521);

  c := 1.11115;
  Check(c = 1.1112);
end;

procedure OLDoubleTest.EqualsDouble;
var
  d: OLDouble;
  i: OLInteger;
begin
  CheckTrue(d = Null);

  d := 3.52;

  CheckFalse(d = Null);

  CheckTrue(d = 3.52);
  CheckFalse(d = 1.1);
  CheckFalse(d = -1.2);
  CheckFalse(d = 0);
  CheckFalse(d = 3.521);

  d := -1.11115;
  Check(d = -1.11115);

  i := 3;
  d := i;
  Check(d = 3);

  d := 0;
  Check(d = 0);
end;

procedure OLCurrencyTest.GreaterCurrency;
var
  c: OLCurrency;
begin
  c := 3.01;

  CheckFalse(c > Null);

  CheckTrue(c > 2.1);
  CheckFalse(c > 3.01);
  CheckFalse(c > 4);
end;

procedure OLCurrencyTest.GreaterEqualCurrency;
var
  c: OLCurrency;
begin
  c := 3.0001;

  CheckFalse(c >= Null);

  CheckTrue(c >= 2.1);
  CheckTrue(c >= 3.0001);
  CheckFalse(c >= 3.0002);

  c := -3;
  CheckFalse(c >= -2.9999);
end;

procedure OLCurrencyTest.LessCurrency;
var
  c: OLCurrency;
begin
  c := 3.1111;

  CheckFalse(c < 3.1111);
  CheckTrue(c < 3.1112);
  CheckTrue(c < 3.11111);
end;

procedure OLCurrencyTest.LessEqualCurrency;
var
  c: OLCurrency;
begin
  c := 3.9999;

  CheckFalse(c <= 2.522);
  CheckTrue(c <= 3.9999);

  c := -2.1234;
  CheckTrue(c <= -2.1234);
end;

procedure OLCurrencyTest.NotEqualCurrency;
var
  c: OLCurrency;
begin
  CheckFalse(c <> Null);

  c := 3.1234;

  CheckTrue(c <> Null);

  CheckTrue(c <> -1.1);
  CheckFalse(c <> 3.1234);
  CheckTrue(c <> 3.12339);
end;

procedure OLCurrencyTest.SetCurrency;
var
  c: OLCurrency;
begin
  c := 1;
  Check(c = 1);

  c := 0;
  Check(c = 0);

  c := '-100';
  Check(c = -100);

  c := 1.12349;
  Check(c = 1.1235);
end;

procedure OLCurrencyTest.IsNullCurrency;
var
  c: OLCurrency;
begin
  Check(c.IsNull());

  c := 1.0001;
  Check(c.IsNull() = False);

  c := Null;
  Check(c.IsNull());
end;

procedure OLCurrencyTest.ToStringCurrency;
var
  c: OLCurrency;
begin
  Check(c.ToString() = EmptyStr);

  c := 123;
  CheckEqualsString(CurrToStrF(123, ffCurrency, 2) , c.ToString());

  c := -100123;
  CheckEqualsString(CurrToStrF(-100123, ffCurrency, 2), c.ToString());
end;

procedure OLCurrencyTest.IfNullCurrency;
var
  c: OLCurrency;
begin
  Check(c.IfNull(1.1) = 1.1);

  c := -1.0001;
  Check(c.IfNull(1) = -1.0001);

  c := null;
  Check(c.IfNull(-5.22) = -5.22);
end;

procedure OLDoubleTest.GreaterDouble;
var
  d: OLDouble;
begin
  d := 3.011;

  CheckFalse(d > Null);

  CheckTrue(d > 2.1);
  CheckFalse(d > 3.011);
  CheckFalse(d > 4.222);
end;

procedure OLDoubleTest.GreaterEqualDouble;
var
  d: OLDouble;
begin
  d := 3.011;

  CheckFalse(d >= Null);

  CheckTrue(d >= 2.1);
  CheckTrue(d >= 3.011);

  d := -3.011;
  CheckFalse(d >= -2.222);
end;

procedure OLDoubleTest.LessDouble;
var
  d: OLDouble;
begin
  d := 3.000003;

  CheckFalse(d < 3.000003);
  CheckTrue(d < 3.1);
end;

procedure OLDoubleTest.LessEqualDouble;
var
  d: OLDouble;
begin
  d := 3.000003;

  CheckFalse(d <= 2.5);
  CheckTrue(d <= 3.000003);

  d := -2.000003;
  CheckTrue(d <= -2.000003);
end;

procedure OLDoubleTest.NotEqualDouble;
var
  d: OLDouble;
begin
  CheckFalse(d <> Null);

  d := 3.000003;

  CheckTrue(d <> Null);

  CheckTrue(d <> -1.1);
  CheckFalse(d <> 3.000003);
end;

procedure OLDoubleTest.SetDouble;
var
  d: OLDouble;
  s: string;
begin
  d := 1;
  Check(d = 1);

  d := 0;
  Check(d = 0);

  d := '-100';
  Check(d = -100);

  d := 1.000003;
  Check(d = 1.000003);

  s := SysUtils.FloatToStr(-100.000003);

  d := s;
  Check(d = -100.000003);
end;

procedure OLDoubleTest.IsNullDouble;
var
  d: OLDouble;
begin
  Check(d.IsNull());

  d := 0.0001;
  Check(d.IsNull() = False);

  d := Null;
  Check(d.IsNull());
end;

procedure OLDoubleTest.ToStringDouble;
var
  d: OLDouble;
begin
  d := 123.00111;
  Check(FloatToStr(123.00111) = d.ToString());
  Check(FloatToStrF(123.00111, ffFixed, 16, 3) = d.ToString(3));

  d := -100123.0243;
  Check(FloatToStr(-100123.0243) = d.ToString());
  Check(FloatToStrF(-100123.0243, ffCurrency, 16, 2) = d.ToString(2, ffCurrency));
end;

procedure OLDoubleTest.IfNullDouble;
var
  d: OLDouble;
begin
  Check(d.IfNull(1.333) = 1.333);

  d := -1.222;
  Check(d.IfNull(1) = -1.222);

  d := null;
  Check(d.IfNull(-5.1) = -5.1);
end;

procedure OLDateTest.EqualsDate;
var
  d, d2: OLDate;
  dt: TDate;
begin
  CheckTrue(d = Null);

  d := EncodeDate(2017,5,4);

  CheckFalse(d = Null);

  dt := EncodeDate(2017,5,4);

  CheckTrue(d = dt);
  CheckFalse(d = Now());

  d := EncodeDateTime(2016,1,10,10,10,10,100);
  d2 := EncodeDate(2016,1,10);
  Check(d = d2);
end;

procedure OLDateTimeTest.EqualsDateTime;
var
  dt: OLDateTime;
  dtt2, dtt3: TDateTime;
begin
  CheckTrue(dt = Null);

  dt := EncodeDateTime(2017,5,4,21,41,50,950);

  CheckFalse(dt = Null);

  dtt2 := EncodeDateTime(2017,5,4,21,41,50,950);
  dtt3 := Now();

  CheckTrue(dt = dtt2);
  CheckFalse(dt = dtt3);
end;

procedure OLDateTest.GreaterEqualDate;
var
  d: OLDate;
  dt, dt2: TDate;
begin
  Check(d >= Null);

  dt := EncodeDate(2016,1,1);
  d := EncodeDate(2017,1,1);
  dt2 := EncodeDate(2018,1,1);

  CheckFalse(d >= Null);

  CheckTrue(d >= dt);
  CheckTrue(d >= d);
  CheckFalse(d >= dt2);
end;

procedure OLDateTimeTest.GreaterEqualDateTime;
var
  dt: OLDateTime;
  dtt2, dtt3: TDateTime;
begin
  Check(dt >= Null);

  dtt2 := Now();
  sleep(10);
  dt := Now();
  sleep(10);
  dtt3 := Now();

  CheckFalse(dt >= Null);

  CheckTrue(dt >= dtt2);
  CheckTrue(dt >= dt);
  CheckFalse(dt >= dtt3);
end;

procedure OLDateTest.GreaterDate;
var
  d: OLDate;
  dt: TDate;
begin
  CheckFalse(d > Null);

  dt := EncodeDate(2016,1,1);
  d := EncodeDate(2017,1,1);

  CheckFalse(d > Null);

  CheckTrue(d > dt);
  CheckFalse(d > d);
end;

procedure OLDateTimeTest.GreaterDateTime;
var
  dt: OLDateTime;
  dtt: TDateTime;
begin
  CheckFalse(dt > Null);

  dtt := Now();
  sleep(10);
  dt := Now();

  CheckFalse(dt > Null);

  CheckTrue(dt > dtt);
  CheckFalse(dt > dt);
end;

procedure OLDateTest.IsNullDate;
var
  dt: OLDate;
begin
  Check(dt.IsNull());

  dt := Today();
  Check(dt.IsNull() = False);

  dt := Null;
  Check(dt.IsNull());
end;

procedure OLDateTimeTest.IsNullDateTime;
var
  dt: OLDateTime;
begin
  Check(dt.IsNull());

  dt := Now();
  Check(dt.IsNull() = False);

  dt := Null;
  Check(dt.IsNull());
end;

procedure OLDateTest.LessEqualDate;
var
  d: OLDateTime;
  dt, dt2: TDateTime;
begin
  Check(d <= Null);

  dt := EncodeDate(2016,1,1);
  d := EncodeDate(2017,1,1);
  dt2 := EncodeDate(2018,1,1);

  CheckFalse(d <= Null);

  CheckTrue(d <= dt2);
  CheckTrue(d <= d);
  CheckFalse(d <= dt);
end;

procedure OLDateTimeTest.LessEqualDateTime;
var
  dt: OLDateTime;
  dtt, dtt2: TDateTime;
begin
  Check(dt <= Null);

  dtt := Now();
  sleep(10);
  dt := Now();
  sleep(10);
  dtt2 := Now();

  CheckFalse(dt <= Null);

  CheckTrue(dt <= dtt2);
  CheckTrue(dt <= dt);
  CheckFalse(dt <= dtt);
end;

procedure OLDateTest.LessDate;
var
  d: OLDate;
  dt: TDate;
begin
  CheckFalse(d > Null);

  d := EncodeDate(2016,1,1);
  dt := EncodeDate(2017,1,1);

  CheckFalse(d > Null);

  CheckTrue(d < dt);
  CheckFalse(d < d);
end;

procedure OLDateTimeTest.LessDateTime;
var
  dt: OLDateTime;
  dtt: TDateTime;
begin
  CheckFalse(dt > Null);

  dt := Now();
  sleep(10);
  dtt := Now();

  CheckFalse(dt > Null);

  CheckTrue(dt < dtt);
  CheckFalse(dt < dt);
end;

procedure OLDateTest.NotEqualDate;
var
  d: OLDate;
  dt: TDate;
begin
  CheckFalse(d <> Null);

  d := EncodeDate(2017,1,1);
  dt := EncodeDate(2016,1,1);

  CheckTrue(d <> Null);

  CheckTrue(d <> dt);
  CheckFalse(d <> d);
end;

procedure OLDateTimeTest.NotEqualDateTime;
var
  dt: OLDateTime;
begin
  CheckFalse(dt <> Null);

  dt := Now();

  CheckTrue(dt <> Null);

  sleep(10);
  CheckTrue(dt <> Now());
  CheckFalse(dt <> dt);
end;

procedure OLDateTest.SetDate;
var
  d: OLDate;
  dt: TDate;
  s: string;
begin
  dt := Today();

  d := dt;
  Check(d = dt);

  dt := EncodeDate(2017,5,4);
  d := dt;
  Check(d = dt);
  CheckFalse(d = Today());

  dt := EncodeDate(2017,5,8);
  s := DateToStr(dt);
  d := s;
  Check(d = dt);

  d := 47123.5;
  Check(d = EncodeDate(2029,1,5));

  d := 'td'; //SmartStrToDate - Today
  Check(d = Today());

  d := 'yd'; //SmartStrToDate - Yesterday
  Check(d = Yesterday());

  d := '2017-05-19';
  Check(d = EncodeDate(2017,5,19));

  d := '2017.05.19';
  Check(d = EncodeDate(2017,5,19));

  d := '2017/05/19';
  Check(d = EncodeDate(2017,5,19));

  d := '620';
  Check(d = EncodeDate(YearOf(Date()),6,20));

  d := '11';
  Check(d = EncodeDate(YearOf(Date()), MonthOf(Date()) ,11));
end;

procedure OLDateTimeTest.SetDateTime;
var
  dt: OLDateTime;
  dtt: TDateTime;
  s: string;
begin
  dtt := Now();

  dt := dtt;
  Check(dt = dtt);

  dtt := EncodeDateTime(2017,5,4,21,58,23,0);
  dt := dtt;
  Check(dt = dtt);
  CheckFalse(dt = Now());

  s := DateTimeToStr(dtt);
  dt := s;
  Check(dt = dtt);

  dt := 47123.5;
  Check(dt = EncodeDateTime(2029,1,5,12,0,0,0));
end;

procedure OLDateTest.ToStringDate;
var
  d: OLDate;
  dt: TDate;
  s: string;
begin
  Check(d.ToString() = '');

  dt := Today();

  d := dt;
  Check(d.ToString() = DateToStr(dt));
end;

procedure OLDateTimeTest.OutPut;
var
  dt: OLDateTime;
  dtt: TDateTime;
  s: string;
begin
  Check(dt.ToString() = '');

  dtt := Now();

  dt := dtt;
  Check(dt.ToString() = DateTimeToStr(dtt));
end;

{ New OLString Tests }

// Null Handling & Basic Operations
procedure OLStringTest.IfNullOrEmptyString;
var
  s: OLString;
begin
  s := Null;
  Check(s.IfNullOrEmpty('Default') = 'Default');

  s := '';
  Check(s.IfNullOrEmpty('Default') = 'Default');

  s := 'Value';
  Check(s.IfNullOrEmpty('Default') = 'Value');
end;

procedure OLStringTest.IsNullOrEmptyString;
var
  s: OLString;
begin
  s := Null;
  Check(s.IsNullOrEmpty());

  s := '';
  Check(s.IsNullOrEmpty());

  s := 'Value';
  CheckFalse(s.IsNullOrEmpty());
end;

procedure OLStringTest.NotNullNorEmptyString;
var
  s: OLString;
begin
  s := Null;
  CheckFalse(s.NotNullNorEmpty());

  s := '';
  CheckFalse(s.NotNullNorEmpty());

  s := 'Value';
  Check(s.NotNullNorEmpty());
end;

procedure OLStringTest.IsEmptyStrString;
var
  s: OLString;
begin
  s := '';
  Check(s.IsEmptyStr());

  s := 'Value';
  CheckFalse(s.IsEmptyStr());

  s := Null;
  Check(s.IsEmptyStr().IsNull());
end;

// Character Manipulation
procedure OLStringTest.AlphanumericsOnlyString;
var
  s: OLString;
begin
  s := 'Hello123!@#World456';
  Check(s.AlphanumericsOnly() = 'Hello123World456');

  s := '!@#$%^&*()';
  Check(s.AlphanumericsOnly() = '');

  s := Null;
  Check(s.AlphanumericsOnly().IsNull());
end;

procedure OLStringTest.NoDigitsString;
var
  s: OLString;
begin
  s := 'Hello123World456';
  Check(s.NoDigits() = 'HelloWorld');

  s := '123456';
  Check(s.NoDigits() = '');

  s := Null;
  Check(s.NoDigits().IsNull());
end;

procedure OLStringTest.RepeatedStringString;
var
  s: OLString;
begin
  s := 'ABC';
  Check(s.RepeatedString(3) = 'ABCABCABC');

  s := 'X';
  Check(s.RepeatedString(5) = 'XXXXX');

  s := Null;
  Check(s.RepeatedString(3).IsNull());
end;

procedure OLStringTest.LikeString;
var
  s: OLString;
begin
  s := 'Hello World';
  Check(s.Like('Hello%'));
  Check(s.Like('%World'));
  Check(s.Like('%o W%'));
  Check(s.Like('Hello_World'));
  Check(s.Like('Hell___orld'));
  CheckFalse(s.Like('Goodbye%'));

  s := Null;
  Check(s.Like('%').IsNull());
end;

// String Pattern Finding
procedure OLStringTest.FindTagStrString;
var
  s: OLString;
begin
  s := '<name>John Doe</name><age>30</age>';
  Check(s.FindTagStr('name') = 'John Doe');
  Check(s.FindTagStr('age') = '30');

  s := '<TITLE>Test</TITLE>';
  Check(s.FindTagStr('title') = 'Test');

  s := Null;
  Check(s.FindTagStr('tag').IsNull());
end;

procedure OLStringTest.FindPatternStrString;
var
  s: OLString;
begin
  s := 'Price: $100.50 USD';
  Check(s.FindPatternStr('$', ' ') = '100.50');

  s := 'Name: [John] Age: [30]';
  Check(s.FindPatternStr('[', ']') = 'John');

  s := Null;
  Check(s.FindPatternStr('[', ']').IsNull());
end;

// Leading Character Operations
procedure OLStringTest.LeadingCharString;
var
  s: OLString;
begin
  s := '123';
  Check(s.LeadingCharIncluded('-') = '-123');
  Check(s.LeadingCharExcluded('-') = '123');

  s := '-123';
  Check(s.LeadingCharExcluded('-') = '123');
  Check(s.LeadingCharIncluded('-') = '-123');

  s := Null;
  Check(s.LeadingCharIncluded('-').IsNull());
  Check(s.LeadingCharExcluded('-').IsNull());
end;

procedure OLStringTest.LeadingComaString;
var
  s: OLString;
begin
  s := '123';
  Check(s.LeadingComaIncluded() = ',123');

  s := ',123';
  Check(s.LeadingComaExcluded() = '123');
  Check(s.LeadingComaIncluded() = ',123');

  s := Null;
  Check(s.LeadingComaIncluded().IsNull());
  Check(s.LeadingComaExcluded().IsNull());
end;

procedure OLStringTest.LeadingApostropheString;
var
  s: OLString;
begin
  s := 'text';
  Check(s.LeadingApostropheIncluded() = '''text');

  s := '''text';
  Check(s.LeadingApostropheExcluded() = 'text');
  Check(s.LeadingApostropheIncluded() = '''text');

  s := Null;
  Check(s.LeadingApostropheIncluded().IsNull());
  Check(s.LeadingApostropheExcluded().IsNull());
end;

// Trailing Apostrophe Operations
procedure OLStringTest.TrailingApostropheString;
var
  s: OLString;
begin
  s := 'text';
  Check(s.TrailingApostropheIncluded() = 'text''');

  s := 'text''';
  Check(s.TrailingApostropheExcluded() = 'text');
  Check(s.TrailingApostropheIncluded() = 'text''');

  s := Null;
  Check(s.TrailingApostropheIncluded().IsNull());
  Check(s.TrailingApostropheExcluded().IsNull());
end;

// URL & HTML Encoding
procedure OLStringTest.UrlEncodedTextString;
var
  s: OLString;
begin
  s := 'Hello%20World';
  s.UrlEncodedText := s;
  Check(s = 'Hello World');

  s := '"Hello World!"';
  Check(s.UrlEncodedText = '%22Hello%20World%21%22');

  s := Null;
  Check(s.UrlEncodedText.IsNull());
end;

procedure OLStringTest.HtmlUnicodeTextString;
var
  s, encoded: OLString;
begin
  s := 'Test & < >';
  encoded := s.HtmlUnicodeText;
  CheckFalse(encoded = s);
  Check(encoded.Length > s.Length);

  s := Null;
  Check(s.HtmlUnicodeText.IsNull());
end;

// Position & Replacement Operations
procedure OLStringTest.ReplacedStartingAtString;
var
  s: OLString;
begin
  s := 'Hello World';
  Check(s.ReplacedStartingAt(7, 'Universe') = 'Hello Universe');

  s := '123456789';
  Check(s.ReplacedStartingAt(4, 'XXX') = '123XXX789');

  s := Null;
  Check(s.ReplacedStartingAt(1, 'Test').IsNull());
end;

procedure OLStringTest.PosLastString;
var
  s: OLString;
  i: OLInteger;
begin
  s := 'My name is Bond. My name is James Bond.';

  i := s.PosLast('Bond');
  Check(i = 35);

  i := s.PosLast('name');
  Check(i = 21);

  i := s.PosLast('xyz');
  Check(i.IsNull());

  s := Null;
  i := s.PosLast('test');
  Check(i.IsNull());
end;

// CSV Operations Advanced
procedure OLStringTest.CSVIndexString;
var
  s: OLString;
begin
  s := 'apple;banana;cherry;date';
  Check(s.CSVIndex('banana') = 1);
  Check(s.CSVIndex('cherry') = 2);
  Check(s.CSVIndex('apple') = 0);
  Check(s.CSVIndex('xyz').IsNull());

  s := Null;
  Check(s.CSVIndex('test').IsNull());
end;

procedure OLStringTest.CSVFieldNameString;
var
  s: OLString;
begin
  s := 'Name;Age;City' + sLineBreak + 'John;30;NYC';
  Check(s.CSVFieldName(0) = 'Name');
  Check(s.CSVFieldName(1) = 'Age');
  Check(s.CSVFieldName(2) = 'City');

  s := Null;
  Check(s.CSVFieldName(0).IsNull());
end;

procedure OLStringTest.CSVFieldByNameString;
var
  s: OLString;
begin
  s := 'Name;Age;City' + sLineBreak + 'John;30;NYC' + sLineBreak + 'Jane;25;LA';
  Check(s.CSVFieldByName('Name', 1) = 'John');
  Check(s.CSVFieldByName('Age', 1) = '30');
  Check(s.CSVFieldByName('City', 2) = 'LA');
  Check(s.CSVFieldByName('Age', 2) = '25');

  s := Null;
  Check(s.CSVFieldByName('test', 1).IsNull());
end;

// Parameter & JSON Operations
procedure OLStringTest.ParamsString;
var
  s: OLString;
begin
  s := 'Hello :name, you are :age years old';
  s.Params['name'] := 'John';
  s.Params['age'] := '30';
  Check(s = 'Hello John, you are 30 years old');

  Check(s.Params['name'] = 'John');
  Check(s.Params['age'] = '30');


  s := 'Hello :Param, you are :Param2 years old';
  s.Params['Param'] := 'John';
  s.Params['Param2'] := '30';
  Check(s = 'Hello John, you are 30 years old');
end;

{$IF CompilerVersion >= 27.0}
procedure OLStringTest.JSONString;
var
  s: OLString;
begin
  s := '{"name":"John","age":30,"city":"NYC"}';
  Check(s.JSON['name'] = 'John');
  Check(s.JSON['age'] = '30');
  Check(s.JSON['city'] = 'NYC');

  s.JSON['name'] := 'Jane';
  Check(s.JSON['name'] = 'Jane');

  s := '{"User":{"name":"John","age":30,"city":"NYC"}}';
  Check(s.JSON['User.name'] = 'John');
  Check(s.JSON['User.age'] = '30');
  Check(s.JSON['User.city'] = 'NYC');

  s.JSON['User.name'] := 'Jane';
  Check(s.JSON['User.name'] = 'Jane');


  s :='{"People":[{"name":"John"},{"name":"Anna"},{"name":"Nick"}]}';
  Check(s.JSON['People[0].name'] = 'John');
  Check(s.JSON['People[1].name'] = 'Anna');
  Check(s.JSON['People[2].name'] = 'Nick');

  s.JSON['People[1].name'] := 'Joanna';
  Check(s.JSON['People[1].name'] = 'Joanna');
  Check(s = '{"People":[{"name":"John"},{"name":"Joanna"},{"name":"Nick"}]}');

  s.JSON['People[3].name'] := 'Kate';
  s.JSON['People[3].age'] := 15;

  Check(s = '{"People":[{"name":"John"},{"name":"Joanna"},{"name":"Nick"},{"name":"Kate","age":15}]}');
end;
{$IFEND}

// Static Methods
procedure OLStringTest.RandomFromString;
var
  s: OLString;
  found: Boolean;
begin
  s := OLString.RandomFrom(['apple', 'banana', 'cherry']);
  found := (s = 'apple') or (s = 'banana') or (s = 'cherry');
  Check(found);

  s := OLString.RandomFrom(['single']);
  Check(s = 'single');
end;

procedure OLStringTest.RandomStringString;
var
  s: OLString;
begin
  s := OLString.RandomString(10);
  Check(s.Length() = 10);

  s := OLString.RandomString(5);
  Check(s.Length() = 5);

  s := OLString.RandomString(0);
  Check(s.Length() = 0);
end;

// Line Operations
procedure OLStringTest.LinesSortedString;
var
  s: OLString;
begin
  s := 'zebra' + sLineBreak + 'apple' + sLineBreak + 'banana';
  s := s.LinesSorted();
  Check(s.Lines[0] = 'apple');
  Check(s.Lines[1] = 'banana');
  Check(s.Lines[2] = 'zebra');

  s := Null;
  Check(s.LinesSorted().IsNull());
end;

procedure OLStringTest.LineIndexLikeString;
var
  s: OLString;
begin
  s := 'First line' + sLineBreak + 'Second line' + sLineBreak + 'Third line';
  Check(s.LineIndexLike('Second%') = 1);
  Check(s.LineIndexLike('Third%') = 2);
  Check(s.LineIndexLike('%line') = 0);
  Check(s.LineIndexLike('%xyz%').IsNull());

  s := Null;
  Check(s.LineIndexLike('test').IsNull());
end;

// Conversion & Utility
procedure OLStringTest.ToSQLStringString;
var
  s: OLString;
begin
  s := 'O''Reilly';
  Check(s.ToSQLString() = '''O''''Reilly''');

  s := 'Simple';
  Check(s.ToSQLString() = '''Simple''');

  s := '';
  Check(s.ToSQLString() = '''''');
end;

procedure OLStringTest.ToPWideCharString;
var
  s: OLString;
  pw: PWideChar;
begin
  s := 'Test String';
  pw := s.ToPWideChar();
  Check(pw <> nil);
  Check(string(pw) = 'Test String');
end;

procedure OLStringTest.LineEndAtString;
var
  s: OLString;
begin
  s := 'First line' + sLineBreak + 'Second line' + sLineBreak + 'Third line';
  Check(s.LineEndAt(0) > 0);
  Check(s.LineEndAt(1) > s.LineEndAt(0));

  s := Null;
  Check(s.LineEndAt(0).IsNull());
end;

// ============================================================================
// NULL Propagation Tests
// ============================================================================

procedure OLIntegerTest.NullPropagationPredicatesInteger;
var
  i: OLInteger;
begin
  // NULL integer should propagate NULL through all value predicate methods
  i := Null;
  
  // Test IsDividableBy
  Check(i.IsDividableBy(2).IsNull(), 'NULL.IsDividableBy should return NULL');
  
  // Test IsEven (relies on IsDividableBy)
  Check(i.IsEven().IsNull(), 'NULL.IsEven should return NULL');
  
  // Test IsOdd  
  Check(i.IsOdd().IsNull(), 'NULL.IsOdd should return NULL');
  
  // Test IsPositive
  Check(i.IsPositive().IsNull(), 'NULL.IsPositive should return NULL');
  
  // Test IsNegative
  Check(i.IsNegative().IsNull(), 'NULL.IsNegative should return NULL');
  
  // Test IsNonNegative
  Check(i.IsNonNegative().IsNull(), 'NULL.IsNonNegative should return NULL');
  
  // Test IsPrime
  Check(i.IsPrime().IsNull(), 'NULL.IsPrime should return NULL');
  
  // Status predicates should still return boolean
  Check(i.IsNull() = True, 'NULL.IsNull should return TRUE');
  Check(i.HasValue() = False, 'NULL.HasValue should return FALSE');
end;

procedure OLDoubleTest.NullPropagationPredicatesDouble;
var
  d: OLDouble;
begin
  // NULL double should propagate NULL through all value predicate methods
  d := Null;
  
  // Test IsPositive
  Check(d.IsPositive().IsNull(), 'NULL.IsPositive should return NULL');
  
  // Test IsNegative
  Check(d.IsNegative().IsNull(), 'NULL.IsNegative should return NULL');
  
  // Test IsNonNegative
  Check(d.IsNonNegative().IsNull(), 'NULL.IsNonNegative should return NULL');
  
  // Test IsNan
  Check(d.IsNan().IsNull(), 'NULL.IsNan should return NULL');
  
  // Test IsInfinite
  Check(d.IsInfinite().IsNull(), 'NULL.IsInfinite should return NULL');
  
  // Test IsZero
  Check(d.IsZero().IsNull(), 'NULL.IsZero should return NULL');
  
  // Status predicates should still return boolean
  Check(d.IsNull() = True, 'NULL.IsNull should return TRUE');
  Check(d.HasValue() = False, 'NULL.HasValue should return FALSE');
end;

procedure OLCurrencyTest.NullPropagationPredicatesCurrency;
var
  c: OLCurrency;
begin
  // NULL currency should propagate NULL through all value predicate methods
  c := Null;
  
  // Test IsPositive
  Check(c.IsPositive().IsNull(), 'NULL.IsPositive should return NULL');
  
  // Test IsNegative
  Check(c.IsNegative().IsNull(), 'NULL.IsNegative should return NULL');
  
  // Test IsNonNegative
  Check(c.IsNonNegative().IsNull(), 'NULL.IsNonNegative should return NULL');
  
  // Status predicates should still return boolean
  Check(c.IsNull() = True, 'NULL.IsNull should return TRUE');
  Check(c.HasValue() = False, 'NULL.HasValue should return FALSE');
end;

procedure OLBooleanTest.NullHandlingBoolean;
var
  b: OLBoolean;
begin
  // NULL boolean should return definitive boolean values for status predicates
  b := Null;
  
  // Status predicates should return boolean
  Check(b.IsNull() = True, 'NULL.IsNull should return TRUE');
  Check(b.HasValue() = False, 'NULL.HasValue should return FALSE');
  
  // Verify with non-null value
  b := True;
  Check(b.IsNull() = False, 'TRUE.IsNull should return FALSE');
  Check(b.HasValue() = True, 'TRUE.HasValue should return TRUE');
  
  b := False;
  Check(b.IsNull() = False, 'FALSE.IsNull should return FALSE');
  Check(b.HasValue() = True, 'FALSE.HasValue should return TRUE');
end;

procedure OLStringTest.NullHandlingString;
var
  s: OLString;
begin
  // NULL string should return definitive boolean values for status predicates
  s := Null;
  
  // Status predicates should return boolean
  Check(s.IsNull() = True, 'NULL.IsNull should return TRUE');
  Check(s.HasValue() = False, 'NULL.HasValue should return FALSE');
  Check(s.IsNullOrEmpty() = True, 'NULL.IsNullOrEmpty should return TRUE');
  
  // Verify with non-null value
  s := 'test';
  Check(s.IsNull() = False, '"test".IsNull should return FALSE');
  Check(s.HasValue() = True, '"test".HasValue should return TRUE');
  Check(s.IsNullOrEmpty() = False, '"test".IsNullOrEmpty should return FALSE');
  
  // Verify with empty string
  s := '';
  Check(s.IsNull() = False, 'Empty string.IsNull should return FALSE');
  Check(s.HasValue() = True, 'Empty string.HasValue should return TRUE');
  Check(s.IsNullOrEmpty() = True, 'Empty string.IsNullOrEmpty should return TRUE');
end;

procedure OLDateTest.NullHandlingDate;
var
  d: OLDate;
begin
  // NULL date should return definitive boolean values for status predicates
  d := Null;
  
  // Status predicates should return boolean
  Check(d.IsNull() = True, 'NULL.IsNull should return TRUE');
  Check(d.HasValue() = False, 'NULL.HasValue should return FALSE');
  
  // Verify with non-null value
  d := EncodeDate(2023, 1, 1);
  Check(d.IsNull() = False, 'Date.IsNull should return FALSE');
  Check(d.HasValue() = True, 'Date.HasValue should return TRUE');
end;

procedure OLDateTimeTest.NullHandlingDateTime;
var
  dt: OLDateTime;
begin
  // NULL datetime should return definitive boolean values for status predicates
  dt := Null;
  
  // Status predicates should return boolean
  Check(dt.IsNull() = True, 'NULL.IsNull should return TRUE');
  Check(dt.HasValue() = False, 'NULL.HasValue should return FALSE');
  
  // Verify with non-null value
  dt := EncodeDateTime(2023, 1, 1, 12, 0, 0, 0);
  Check(dt.IsNull() = False, 'DateTime.IsNull should return FALSE');
  Check(dt.HasValue() = True, 'DateTime.HasValue should return TRUE');
end;

procedure OLIntegerTest.ShortCircuitInteger;
var
  i1, i2: OLInteger;
  WasCalled: Boolean;

  function SideEffect: Boolean;
  begin
    WasCalled := True;
    Result := True;
  end;

begin
  // Case 1: First operand is False (10 = 20 is False)
  // Short-circuiting (False AND ...) means SideEffect should NOT be called.
  i1 := 10;
  i2 := 20;
  WasCalled := False;
  
  if (i1 = i2) and SideEffect then
  begin
    // Should not be reached
  end;
  
  CheckFalse(WasCalled, 'Short-circuiting failed: SideEffect was called when first operand was False');

  // Case 2: First operand is True (10 = 10 is True)
  // No short-circuiting (True AND ...) means SideEffect SHOULD be called.
  i1 := 10;
  i2 := 10;
  WasCalled := False;
  
  if (i1 = i2) and SideEffect then
  begin
    // Should be reached
  end;
  
   CheckTrue(WasCalled, 'Short-circuiting failed: SideEffect was NOT called when first operand was True');
end;



initialization
  // Register any test cases with the test runner
  RegisterTest(OLBooleanTest.Suite);
  RegisterTest(OLIntegerTest.Suite);
  RegisterTest(OLCurrencyTest.Suite);
  RegisterTest(OLDoubleTest.Suite);
  RegisterTest(OLDateTimeTest.Suite);
  RegisterTest(OLDateTest.Suite);
  RegisterTest(OLStringTest.Suite);


end.

